### 남일우
#### 1. 생활 컨텐츠 이식 작업 (천상비M -> 조선협객전 2M식 코드로 이식 패킷은 클라이언트와 작업필요)
<details>
<summary>생활</summary>
  
  ```ruby
struct LifeResultData
{
	INT32 _i32ResultItemIndex;
	INT32 _i32Percent;
	INT32 _i32Count;
};


enum LIFE_OBJECT_TYPE
{
	LIFE_DATA_OBJECT_TILE,
	LIFE_DATA_OBJECT_NPC,
	LIFE_DATA_OBJECT_MAX,
};

class CLifeData
{
public:
	CLifeData() {}
	CLifeData(INT32 i32EquipItemIndex) { _i32EquipIndex = i32EquipItemIndex; }

	~CLifeData() {}

	void PushData(INT32 i32ResultItem, INT32 i32Precent, INT32 i32Count);
	INT32 GetResultItem();
	vector<LifeResultData>& GetData() {	return _vResultData;  };

private:
	INT32 _i32EquipIndex;
	vector<LifeResultData> _vResultData;
};

class CLifeManager
{
public:
	CLifeManager() {}
	~CLifeManager() {}

	void Release();
	void LoadData();
	void ReloadLifeInfo();
	void ReloadLifeSujibInfo();
	void ReloadLifeExp();
	void ReloadLifeMonthlyFee();
	void ReloadLifeExpSetting();

	INT32 GetRewardItemIndex(INT32 i32EquipItemIndex);
	INT32 GetRewardItemCountFromIndex(INT32 i32EquipItemIndex,INT32 i32ItemIndex); // 23.10.10 진공 csv 갯수추가
	BOOL LifeAction(INT32 i32Type,CUnitPC* pPC, INT32 i32Direction, BOOL bRelay = FALSE);

	void AddLifeExp(CUnitPC* pPC, INT32 i32LifeType);
	void AddFameExp(CUnitPC* pPC);
	void UpdateLevelByExp(CUnitPC* pPC, INT32 i32LifeType);
	_CSV_1003BM_LIFE_SUJIB_DATA* FindLifeSujibData(INT32 i32LifeType, INT32 i32Level);
	INT32 GetLevelUpExp(INT32 i32LifeType, INT32 i32CurLevel);
	_CSV_1003BM_LIFE_MONTHLY_FEE_DATA* FindLifeMonthlyFeeData(INT32 i32CashStoreIndex);

	void GmSetLifeLevel(CUnitPC* pPC, INT32 i32LifeType, INT32 i32Level);	//운영자 명령어
private:
	map<INT32,CLifeData*> _mapLifeData; // 키값은 아이템 인덱스
	_CSV_1003BM_LIFE_SUJIB_DATA _lifeSujibData[LIFE_DATA_TYPE::LIFE_DATA_TYPE_MAX][MAX_LIFE_LEVEL + 1];	// 수집효과 [생활타입][레벨]
	_CSV_1003BM_LIFE_EXP_DATA _lifeExpData[MAX_LIFE_LEVEL + 1];	//경험치 [레벨]
	map<INT32, _CSV_1003BM_LIFE_MONTHLY_FEE_DATA*> _mapLifeMonthlyFeeData;	//월정액 [캐시스토어idx][월정액data]
	vector<_CSV_1003BM_LIFE_EXP_SETTING_DATA*> _vecLifeExpSettingData;	//명성 구간 별 획득 경험치 계산 상수
};

class CLifeList
{
public:
	CLifeList() { Init(); }
	~CLifeList() {}

	void Init();

	void SetLifeInfo(stLifeInfo* stLifeInfo);
	void SendLifeInfo(CUnitPC* pPC);
	void SaveLifeInfo(CUnitPC* pPC);
	void LifeAbilityUpdate(CUnitPC* pPC, BOOL bSend);

	INT32 GetLevel(INT32 i32LifeType);
	void SetLevel(INT32 i32LifeType, INT32 i32Level);
	INT32 GetExp(INT32 i32LifeType);
	void SetExp(INT32 i32LifeType, INT32 i32Exp);
	void AddExp(INT32 i32LifeType, INT32 i32Exp);

	//월정액
	void SetLifeMonthlyFeeInfo(stLifeMonthlyFeeInfo* stLifeMonthlyFeeInfo);
	void SendLifeMonthlyFeeInfo(CUnitPC* pPC);
	void AddLifeMonthlyFee(CUnitPC* pPC, INT32 i32CashStoreIndex);
	void LifeMonthlyFeeAbilityUpdate(CUnitPC* pPC, BOOL bSend);
	void LoopMonthlyFeeEnd(CUnitPC* pPC);

private:
	stLifeInfo _stLifeInfo[LIFE_DATA_TYPE::LIFE_DATA_TYPE_MAX];
	unordered_map<INT32, INT32> _mapLifeMonthlyFeeInfo;
};

  ```
</details>

<details>
<summary>경맥</summary>
  
  ```ruby
class CUnitPC;
struct GyeongMaekPercentData
{
	INT32 _i32Point;
	INT32 _i32CostType;
	INT32 _i32Percent[MAX_GYEONGMAEK_PER_OPEN];
	INT32 _i32ResetType;
	INT32 _i32ResetCost;
};

struct GyeongMaekPartsData
{
	INT32 _i32Option[MAX_RELLIC_PARTS_OPTION];
	INT32 _i32Value[MAX_RELLIC_PARTS_OPTION];
	INT32 _i32RewardSkillIndex[MAX_JOB_TYPE];
	INT32 _i32ConditionType; // 조건타입
	INT32 _i32ConditionValue; // 조건벨류 
};

class CGyeongMaekManager
{
public:
	CGyeongMaekManager();
	~CGyeongMaekManager() {};
	void LoadData();
	void OnGyeongMaekEnchant(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup);
	//
	void ResetGyeongMaekList(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup);
	//
	void OnCSCouponGyeonMaek(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup);
	//
	void PaybackMaterial(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup);
	//
	void GetAbility(INT32 i32Group, INT32 i32SubGroup, INT32 i32Step,INT32* _Add_Ability, INT32* _Increase_Ability, vector<INT32>* pDecreaseAb);
	//
	BOOL CheckOpenAll(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup);
	INT32 GetRewardSkillIndex(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup);
	void CheckRewardSkillAndOpen(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup,INT32 i32Count);
	//
	BOOL CheckData(INT32 i32Group, INT32 i32SubGroup);
	INT32 GetRewardSkillIndex(INT32 i32Group, INT32 i32SubGroup,INT32 i32Job);

	BOOL CheckGyungmaekSkill(INT32 i32SkillIndex,INT32 i32Job);

	INT32 GetMaxTryCount(INT32 i32Group, INT32 i32Tab);
	void GMGyungmaek(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup, INT32 i32Step);
private:
	GyeongMaekPercentData _stEnchantData[MAX_GYEONGMAEK_GROUP][MAX_GYEONGMAEK_TAB][MAX_GYEONGMAEK_TRY_PER_PAGE];
	GyeongMaekPartsData _stPartsData[MAX_GYEONGMAEK_GROUP][MAX_GYEONGMAEK_TAB][MAX_GYEONGMAEK_PARTS_PER_PAGE];

	set<INT32> _RewardSkillIndex[MAX_JOB_TYPE];
	BOOL bCSCouponUse;
};

extern CGyeongMaekManager g_GyeongMaekManager;


class CUnitPC;
class CGyeongMaekList
{
public:
	CGyeongMaekList();
	~CGyeongMaekList() {};
	void Init();

	void SendGyeongMaekList(CUnitPC* pPC);

	void OpenParts(INT32 i32Group, INT32 i32Tab, INT32 i32PartsIndex);
	void AddEnchantCount(INT32 i32Group, INT32 i32Tab);
	
	void GetList(INT32* pList);
	void SetList(INT32* pList);
	//
	void ResetList();
	void PaybackMaterial(CUnitPC* pPC, INT32 i32Group, INT32 i32Tab);
	void InitResetValue();
	void SetResetValue(INT32 i32Group, INT32 i32Tab);
	//
	void AbilityUpdate(INT32* _Add_Ability, INT32* _Increase_Ability, vector<INT32>* pDecreaseAb);

	INT32 GetEnchantCount(INT32 i32Group, INT32 i32Tab);
	INT32 GetOpenIndex(INT32 i32Group, INT32 i32Tab);

	BOOL GetInitProcess() { return _bInitProcess; }
	void SetInitProcess(BOOL bInit) { _bInitProcess = bInit; }
	//김태수_천장 시스템 추가(경맥)_230424
	void UpCombineCount(CUnitPC* pPC);
	void LoadCombineCount(INT32* i32CombineCount);
	void SaveCombineCount(CUnitPC* pPC);
	void SendCombineCount(CUnitPC* pPC);
	void UseCombineCount(CUnitPC* pPC, INT32 i32Grade); //횟수 사용 및 차감

	INT32 GetOpenGyeongmaekCount();
private:
	INT32 _i32GyeongMaekInfo[MAX_GYEONGMAEK_GROUP][MAX_GYEONGMAEK_TAB][MAX_GYEONGMAEK_PARTS_PER_PAGE]; // 열려있는지 닫혔는지 정보
	INT32 _i32yTryEnchant[MAX_GYEONGMAEK_GROUP][MAX_GYEONGMAEK_TAB]; // 강화횟수 

	BOOL _bInitProcess;
	//김태수_천장 시스템 추가(경맥)_230424
	INT32 _i32CombineCount[COMBINE_COUNT_RANK::COMBINE_MAX]; //횟수
	INT32 _i32CombineRewardCount[COMBINE_COUNT_RANK::COMBINE_MAX]; //1회 보상 필요 횟수

	INT32 _i32InitGroup;
	INT32 _i32InitTab;
};


  ```
</details>


#### 2. CashManager 정리 작업
조선협객전 2M에서 미사용하는 함수들이 많아 정리하였음. 교차검증을 통해 확인 완료

<details>
<summary>기존 코드</summary>

```ruby

class CCashManager
{
public:
	CCashManager();
	bool m_bCash_Purchase[MAX_CASH_SHOP_COUNT];
	list<stCashProcessInfo> _stCashProcessList;
	INT64 _i64CashProcessID;
	map<INT32, queue<stCashTrade*>> _stCashTradeInfoList;
	map<INT32, stCashTrade*> _mapCashTradeInfo;
	INT32 _i32CashInfoUnique;

	static void ON_DSM_CONSUME(BYTE* pPacket);
	static void ON_DSM_CONSUME_SILVER(BYTE* pPacket);
	static void ON_DSM_CONSUME_ETC(BYTE* pPacket);
	static void ON_DSM_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_DEPOSIT_SILVER(BYTE* pPacket);
	static void ON_DSM_DEPOSIT_ETC(BYTE* pPacket);

	static void ON_DSM_CANCEL(BYTE* pPacket);
	static void ON_DSM_BALANCE(BYTE* pPacket);


	static BOOL CONSUME(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, DWORD dwCashUnique, INT32 i32CostType, CUnitPC* pPC, int Price, DWORD dwMemo, WCHAR* pMemo, INT32 i32Type, INT64 i64Bundleunique, cashandtrade* cashtrade = NULL, WCHAR* wSellerName = NULL, DWORD dwSellerAccUnique = 0, int detail1 = 0, int detail2 = 0, int detail3 = 0);
	static BOOL DEPOSIT(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, DWORD dwCashUnique, INT32 i32CostType , CUnitPC* pPC, int Price, DWORD _iProductIdx, WCHAR* pMemo, INT32 i32Type, INT64 _dwProducUnique, cashandtrade* cashtrade = NULL);
	static BOOL CANCEL(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, INT32 i32CostType, DWORD dwAccUnique, DWORD dwCharUnique, DWORD dwFieldUnique, int Price, WCHAR* pMemo, INT64 cashId);
	static BOOL BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, DWORD dwCashUnique, INT32 i32CostType, CUnitPC* pPC);

	static BOOL CONSUME_NEW(ENUM_CASH_TABLE_TYPE eTableType, INT32 i32TradeType, CUnitPC* pPC,DWORD dwMainUnique, DWORD dwSubUnique,INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);
	static BOOL DEPOSIT_NEW(ENUM_CASH_TABLE_TYPE eTableType, INT32 i32TradeType, CUnitPC* pPC, DWORD dwMainUnique, DWORD dwSubUnique, INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);

	static BOOL DEPOSIT_ETCCost(ENUM_CASH_TABLE_TYPE eTableType, INT32 i32CostType, INT32 i32TradeType, CUnitPC* pPC, DWORD dwMainUnique, DWORD dwSubUnique, INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);
	static BOOL CONSUME_ETCCost(ENUM_CASH_TABLE_TYPE eTableType, INT32 i32CostType, INT32 i32TradeType, CUnitPC* pPC, DWORD dwMainUnique, DWORD dwSubUnique, INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);


	//static BOOL CONSUME(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, DWORD dwCashUnique, BOOL bGold, CUnitPC* pPC, int Price, DWORD dwMemo, WCHAR* pMemo, INT32 i32Type, INT64 i64Bundleunique, cashandtrade* cashtrade = NULL, WCHAR* wSellerName = NULL, DWORD dwSellerAccUnique = 0, int detail1 = 0, int detail2 = 0 ,int detail3 = 0);
	//static BOOL DEPOSIT(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, DWORD dwCashUnique,BOOL bGold, CUnitPC* pPC, int Price, DWORD _iProductIdx, WCHAR* pMemo, INT32 i32Type, INT64 _dwProducUnique, cashandtrade* cashtrade = NULL);
	//static BOOL CONSUME(BOOL bGold ,CUnitPC* pPC, int Price, DWORD dwMemo, WCHAR* pMemo, BYTE _Type, INT64 i64Bundleunique, cashandtrade* cashtrade = NULL, WCHAR * wSellerName = NULL, DWORD dwSellerAccUnique = 0 );
	//static BOOL DEPOSIT(BOOL bGold, CUnitPC* pPC, int Price, DWORD _iProductIdx,WCHAR* pMemo, BYTE _Type, INT64 _dwProducUnique, cashandtrade* cashtrade = NULL);
	//static BOOL CANCEL(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, BOOL bGold, DWORD dwAccUnique, DWORD dwCharUnique, DWORD dwFieldUnique, int Price, WCHAR* pMemo, INT64 cashId);
	//static BOOL BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, BOOL bGold, CUnitPC* pPC);

	static BOOL NOT_PC_CONSUME(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, BOOL bGold, DWORD dwAccunique,DWORD dwCharunique, int Price, DWORD dwMemo, WCHAR* pMemo, INT32 i32Type, INT64 i64Bundleunique, cashandtrade* cashtrade = NULL, WCHAR* wSellerName = NULL, DWORD dwSellerAccUnique = 0);
	static BOOL NOT_PC_DEPOSIT(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, BOOL bGold, DWORD dwAccunique, DWORD dwCharunique, int Price, DWORD _iProductIdx, WCHAR* pMemo, INT32 i32Type, INT64 _dwProducUnique, cashandtrade* cashtrade = NULL);
	void SetCashPurchase(char* param, char* productIndex);
	//static void SetSendMsgTypeStr(INT32 i32Type, DCP_REQUEST_CASH* pSendmsg);
	static void SetSendMsgTypeStr(INT32 i32Type, char eTypeStr[CASH_TYPE_TEXT_LENGTH]);

	//거래 진행 차감할곳 , 증감할곳 
	static BOOL CASH_TRADE(ENUM_CASH_TABLE_TYPE eType, ENUM_CASH_TABLE_TYPE eTargetType, DWORD dwMainunique, DWORD dwSubunique, DWORD dwTargetMainUnique,DWORD dwTargetSubUnique,
		INT32 i32Price, INT32 i32TradeType, INT32 i32CashUnique,INT32 i32Detail1, INT32 i32Detail2, INT32 i32TargetDetail1, INT32 i32TargetDetail2);
	//유저 금화 아이템 구매(상점 금화 아이템 구매, 
	static BOOL CASH_USER_BUY(CUnitPC* pPC, INT32 i32ProductID ,INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique, INT32 i32BundleUnique);
	//유저 금화 제외한 기타재화로 아이템 구매
	static BOOL ETCCost_USER_BUY(CUnitPC* pPC, INT32 i32ProductID, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique, INT32 i32BundleUnique,INT32 i32CostType);
	//유저 문파 컨텐츠 이용 (기여)
	static BOOL CASH_USER_MUNPA_USE(CUnitPC* pPC, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	//문파 컨텐츠 이용 (문파 버프 구매 등)
	static BOOL CASH_MUNPA_USE(CUnitPC* pPC, DWORD dwTargetUnique , INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	//거래소 이용
	static BOOL CASH_USER_TRADE(CUnitPC* pPC,DWORD dwSellerUnique, DWORD dwSellerCharunique,INT32 i32TradeIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_USER_TRADE_STORAGE_FIND(CUnitPC* pPC, INT32 i32Price,INT32 i32TradeType, INT32 i32TradeIdx,INT64 i64CashUnique);
	//역참 이용
	static BOOL CASH_STATION_DAY(CUnitPC* pPC,INT32 i32StationIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_CALCULATE_GNI(INT32 i32StationIdx, INT32 i32Value, INT32 i32GinTax, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_CALCULATE_GNI_RETURN(INT32 i32StationIdx, INT32 i32Value, INT32 i32GinTax, DWORD dwReturnMunpaUnique, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_CALCULATE(INT32 i32StationIdx, INT32 i32castleIdx, INT32 i32GinTax,INT32 i32castleTax, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_CALCULATE_RETURN(INT32 i32StationIdx, INT32 i32castleIdx, INT32 i32GinTax, INT32 i32castleTax, DWORD dwReturnMunpaUnique ,INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_USE(CUnitPC* pPC, INT32 i32StationIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_BID_SUCCESS(DWORD dwMunpaUnique, INT32 i32StationIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_BID_FAIL(DWORD dwMunpaUnique, INT32 i32StationIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_MAIL_INPUT(CUnitPC* pPC, DWORD dwMailUnique, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STORAGE_INPUT(CUnitPC* pPC, DWORD dwStorgeIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL ETCCost_MAIL_INPUT(CUnitPC* pPC, DWORD dwMailUnique, INT32 i32CostType, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);

	static BOOL CASH_STATION_OBLATION(CUnitPC* pPC, INT32 i32StationIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);

	// 다이아 가져오기
	static void CASH_BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwMainUnique, DWORD dwSubUnique, CUnitPC* pPC);
	static void WORLD_CASH_BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwMainUnique, DWORD dwSubUnique, CUnitPC* pPC);
	// 기타 재화들 가져오기
	static void ETCCost_BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwMainUnique, DWORD dwSubUnique, CUnitPC* pPC);

	//취소 처리
	static void CASH_ALL_CANCEL(BYTE* pPacket);

	static void ON_DSM_CASH_TRADE(BYTE* pPacket);
	static void ON_DSM_CASH_TRADE_GNI(BYTE* pPacket);
	static void ON_DSM_CASH_TRADE_GNI_RETURN(BYTE* pPacket);
	static void ON_DSM_CASH_TRADE_STORAGE(BYTE* pPacket);
	static void ON_DSM_CASH_CALCULATE(BYTE* pPacket);
	static void ON_DSM_CASH_CALCULATE_RETURN(BYTE* pPacket);
	static void ON_DSM_CASH_ALL_CANCEL(BYTE* pPacket);
	static void ON_DSM_CASH_BALANCE(BYTE* pPacket);

	static void ON_DSM_CONSUME_NEW(BYTE* pPacket);
	static void ON_DSM_DEPOSIT_NEW(BYTE* pPacket);

	static void ON_DSM_ETCCost_TRADE(BYTE* pPacket);
	static void ON_DSM_ETCCost_BALANCE(BYTE* pPacket);
	static void ON_DSM_CONSUME_ETCCost(BYTE* pPacket);
	static void ON_DSM_DEPOSIT_ETCCost(BYTE* pPacket);

	//유저 캐쉬
	static void ON_DSM_USER_CONSUME(BYTE* pPacket);
	static void ON_DSM_USER_CONSUME_SILVER(BYTE* pPacket);
	static void ON_DSM_USER_CONSUME_ETC(BYTE* pPacket);
	static void ON_DSM_USER_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_USER_DEPOSIT_SILVER(BYTE* pPacket);
	static void ON_DSM_USER_DEPOSIT_ETC(BYTE* pPacket);
	static void ON_DSM_USER_CANCEL(BYTE* pPacket);
	static void ON_DSM_USER_BALANCE(BYTE* pPacket);
	
	//문파 캐쉬
	static void ON_DSM_MUNPA_CONSUME(BYTE* pPacket);
	static void ON_DSM_MUNPA_CONSUME_SILVER(BYTE* pPacket);
	static void ON_DSM_MUNPA_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_MUNPA_DEPOSIT_SILVER(BYTE* pPacket);
	static void ON_DSM_MUNPA_CANCEL(BYTE* pPacket);
	static void ON_DSM_MUNPA_BALANCE(BYTE* pPacket);
	
	//성 캐쉬
	static void ON_DSM_CASTLE_CONSUME(BYTE* pPacket);
	static void ON_DSM_CASTLE_CONSUME_SILVER(BYTE* pPacket);
	static void ON_DSM_CASTLE_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_CASTLE_DEPOSIT_SILVER(BYTE* pPacket);
	static void ON_DSM_CASTLE_CANCEL(BYTE* pPacket);
	static void ON_DSM_CASTLE_BALANCE(BYTE* pPacket);
	
	//GNI 세금 -> 빼는 것은 없고 넣는 것만 있다.
	static void ON_DSM_GNI_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_GNI_DEPOSIT_SILVER(BYTE* pPacket);
	static void ON_DSM_GNI_CANCEL(BYTE* pPacket);
	static void ON_DSM_GNI_BALANCE(BYTE* pPacket);
	
	//성 일일 정산 세금
	static void ON_DSM_CASTLE_DAY_CONSUME(BYTE* pPacket);
	static void ON_DSM_CASTLE_DAY_CONSUME_SILVER(BYTE* pPacket);
	static void ON_DSM_CASTLE_DAY_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_CASTLE_DAY_DEPOSIT_SILVER(BYTE* pPacket);
	static void ON_DSM_CASTLE_DAY_CANCEL(BYTE* pPacket);
	static void ON_DSM_CASTLE_DAY_BALANCE(BYTE* pPacket);
	
	//거래소 세금
	static void ON_DSM_TRADE_CONSUME(BYTE* pPacket);
	static void ON_DSM_TRADE_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_TRADE_CANCEL(BYTE* pPacket);
	
	//메일 잔금
	static void ON_DSM_MAIL_CONSUME(BYTE* pPacket);
	static void ON_DSM_MAIL_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_MAIL_CANCEL(BYTE* pPacket);
	
	//역참 잔금
	static void ON_DSM_STATION_CONSUME(BYTE* pPacket);
	static void ON_DSM_STATION_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_STATION_CANCEL(BYTE* pPacket);
	static void ON_DSM_STATION_BALANCE(BYTE* pPacket);
	
	//역참 일일 정산 세금
	static void ON_DSM_STATION_DAY_CONSUME(BYTE* pPacket);
	static void ON_DSM_STATION_DAY_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_STATION_DAY_CANCEL(BYTE* pPacket);
	static void ON_DSM_STATION_DAY_BALANCE(BYTE* pPacket);
	
	//역참 경매
	static void ON_DSM_STATION_BID_CONSUME(BYTE* pPacket);
	static void ON_DSM_STATION_BID_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_STATION_BID_CANCEL(BYTE* pPacket);
	static void ON_DSM_STATION_BID_BALANCE(BYTE* pPacket);

	// 공성 던전 분배
	static void ON_DSM_CASTLE_DISTRIBUTE(BYTE* pPacket);

	stCashProcessInfo* FindCashProcess(DWORD dwID);
	void EraseCashProcess(DWORD dwID);
	INT32 AddCashProcess(INT64* i64Value, INT32 i32Table);
	stCashTrade* GetCashTrade(ENUM_CASH_TRADE_TYPE eCashType);
	void ReturnCashTrade(stCashTrade* pInfo);
	stCashTrade* FindCashTrade(INT32 i32CashUnqiue);
};
```

</details>


<details>
<summary>변경 후</summary>

```ruby
class CCashManager
{
public:
	CCashManager();
	bool m_bCash_Purchase[MAX_CASH_SHOP_COUNT];
	list<stCashProcessInfo> _stCashProcessList;
	INT64 _i64CashProcessID;
	map<INT32, queue<stCashTrade*>> _stCashTradeInfoList;
	map<INT32, stCashTrade*> _mapCashTradeInfo;
	INT32 _i32CashInfoUnique;

	//////////////////////////////////////////////////////
	///				CashDB - > Game					//////
	//////////////////////////////////////////////////////
	static void ON_DSM_CONSUME_NEW(BYTE* pPacket);
	static void ON_DSM_DEPOSIT_NEW(BYTE* pPacket);

	static void ON_DSM_CASH_TRADE(BYTE* pPacket);
	static void ON_DSM_CASH_TRADE_GNI(BYTE* pPacket);
	static void ON_DSM_CASH_TRADE_GNI_RETURN(BYTE* pPacket);
	static void ON_DSM_CASH_TRADE_STORAGE(BYTE* pPacket);

	static void ON_DSM_CASH_CALCULATE(BYTE* pPacket);
	static void ON_DSM_CASH_CALCULATE_RETURN(BYTE* pPacket);

	static void ON_DSM_ETCCost_TRADE(BYTE* pPacket);
	static void ON_DSM_ETCCost_BALANCE(BYTE* pPacket);
	static void ON_DSM_CONSUME_ETCCost(BYTE* pPacket);
	static void ON_DSM_DEPOSIT_ETCCost(BYTE* pPacket);
	//밸런스 반영
	static void ON_DSM_CASH_BALANCE(BYTE* pPacket);
	//취소 처리
	static void ON_DSM_CANCEL(BYTE* pPacket);
	static void CASH_ALL_CANCEL(BYTE* pPacket);
	static void ON_DSM_USER_CANCEL(BYTE* pPacket);
	static void ON_DSM_MUNPA_CANCEL(BYTE* pPacket);

	//////////////////////////////////////////////////////
	///				Game - > CashDB					//////
	//////////////////////////////////////////////////////
	static BOOL CASH_USER_CONSUME_ALLTYPE(ENUM_CASH_TABLE_TYPE eTableType, CASH_TYPE i32TradeType, CUnitPC* pPC,DWORD dwMainUnique, DWORD dwSubUnique,INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);
	static BOOL CASH_USER_DEPOSIT_ALLTYPE(ENUM_CASH_TABLE_TYPE eTableType, CASH_TYPE i32TradeType, CUnitPC* pPC, DWORD dwMainUnique, DWORD dwSubUnique, INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);
	static BOOL DEPOSIT_ETCCost(ENUM_CASH_TABLE_TYPE eTableType, INT32 i32CostType, INT32 i32TradeType, CUnitPC* pPC, DWORD dwMainUnique, DWORD dwSubUnique, INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);
	static BOOL CONSUME_ETCCost(ENUM_CASH_TABLE_TYPE eTableType, INT32 i32CostType, INT32 i32TradeType, CUnitPC* pPC, DWORD dwMainUnique, DWORD dwSubUnique, INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);

	static BOOL CASH_MAIL_INPUT(CUnitPC* pPC, DWORD dwMailUnique, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STORAGE_INPUT(CUnitPC* pPC, DWORD dwStorgeIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL ETCCost_MAIL_INPUT(CUnitPC* pPC, DWORD dwMailUnique, INT32 i32CostType, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);

	//컨텐츠 전용
	//유저 금화 아이템 구매(상점 금화 아이템 구매, 
	static BOOL CASH_USER_BUY(CUnitPC* pPC, INT32 i32ProductID ,INT32 i32Price, CASH_TYPE eTradeType, INT64 i64CashUnique, INT32 i32BundleUnique);
	//유저 금화 제외한 기타재화로 아이템 구매
	static BOOL ETCCost_USER_BUY(CUnitPC* pPC, INT32 i32ProductID, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique, INT32 i32BundleUnique,INT32 i32CostType);
	//유저 문파 컨텐츠 이용 (기여)
	static BOOL CASH_USER_MUNPA_USE(CUnitPC* pPC, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	//문파 컨텐츠 이용 (문파 버프 구매 등)
	static BOOL CASH_MUNPA_USE(CUnitPC* pPC, DWORD dwTargetUnique , INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	//거래소 이용
	static BOOL CASH_USER_TRADE(CUnitPC* pPC,DWORD dwSellerUnique, DWORD dwSellerCharunique,INT32 i32TradeIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_USER_TRADE_STORAGE_FIND(CUnitPC* pPC, INT32 i32Price,INT32 i32TradeType, INT32 i32TradeIdx,INT64 i64CashUnique);

	// 밸런스 요청
	static void CASH_BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwMainUnique, DWORD dwSubUnique, CUnitPC* pPC);
	static void WORLD_CASH_BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwMainUnique, DWORD dwSubUnique, CUnitPC* pPC);
	static void ETCCost_BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwMainUnique, DWORD dwSubUnique, CUnitPC* pPC);

	// 취소 요청
	static BOOL CANCEL(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, INT32 i32CostType, DWORD dwAccUnique, DWORD dwCharUnique, DWORD dwFieldUnique, int Price, WCHAR* pMemo, INT64 cashId);

	
	//////////////////////////////////////////////////////
	///						기타						//////
	//////////////////////////////////////////////////////
	void SetCashPurchase(char* param, char* productIndex);
	static void SetSendMsgTypeStr(INT32 i32Type, char eTypeStr[CASH_TYPE_TEXT_LENGTH]);

	stCashProcessInfo* FindCashProcess(DWORD dwID);
	void EraseCashProcess(DWORD dwID);
	INT32 AddCashProcess(INT64* i64Value, INT32 i32Table);
	stCashTrade* GetCashTrade(ENUM_CASH_TRADE_TYPE eCashType);
	void ReturnCashTrade(stCashTrade* pInfo);
	stCashTrade* FindCashTrade(INT32 i32CashUnqiue);
};

```

</details>


#### 3. CSV파일 컬럼명 읽기 작업 사용문서 적용
<details>
<summary>기존 코드</summary>

```ruby
bool LoadDataFile()
	{
		Clear();

		int i = 0;
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32Index));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32Floor)); 
		i++; // 클라에서 월드 찾기 위한 컬럼 0 서버, 1 월드
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32MapIndex));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32BossNpcIndex));
		i++;
		i++;
		i++;
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterCostType));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterCostValue));
		i++;
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32OpenHour));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32OpenMinute));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32CloseHour));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32CloseMinute));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnPositionX));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnPositionY));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnHour));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnMinute));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnDays));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32LimitMinute));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterLimitLevelMin));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterLimitLevelMax));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterLimitBossIndex));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32MaxPlayerCount));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ExitTime));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32WarpX));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32WarpY));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32HpWeight));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ReturnMapIndex));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ReturnXPos));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ReturnYPos));

		SetKeyField(0);

		char szFile[256];
		g_Global.GetRootPath();
		sprintf(szFile, "%s\\_DATA\\1003B2M_BossRaidInfo.csv", g_Global.m_szRootPath);
		if (LoadCSVFile(szFile) == false)
		{
			printf("Can't load data file (%s).\n", szFile);
			return false;
		}
		Close();
		return true;
	}
```

</details>


<details>
<summary>변경 코드</summary>

```ruby
	bool LoadDataFile()
	{
		Clear();
		char szFile[256];
		g_Global.GetRootPath();
		sprintf(szFile, "%s\\_DATA\\1003B2M_BossRaidInfo.csv", g_Global.m_szRootPath);
		if (LoadHeader(szFile) == false)
		{
			printf("Can't load data file (%s).\n", szFile);
			return false;
		}


		AddField(GetColumnIndex("Index"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32Index));
		AddField(GetColumnIndex("Stairs"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32Floor));
	
		AddField(GetColumnIndex("MapIndex"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32MapIndex));
		AddField(GetColumnIndex("BossIndex"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32BossNpcIndex));

		AddField(GetColumnIndex("EntranceCostType"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterCostType));
		AddField(GetColumnIndex("EntranceCost"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterCostValue));

		AddField(GetColumnIndex("OpenTime"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32OpenHour));
		AddField(GetColumnIndex("OpenMinute"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32OpenMinute));
		AddField(GetColumnIndex("CloseTime"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32CloseHour));
		AddField(GetColumnIndex("CloseMinute"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32CloseMinute));
		AddField(GetColumnIndex("SpawnX"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnPositionX));
		AddField(GetColumnIndex("SpawnY"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnPositionY));
		AddField(GetColumnIndex("SpawnTime"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnHour));
		AddField(GetColumnIndex("SpawnMinute"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnMinute));
		AddField(GetColumnIndex("SpawnDays"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnDays));
		AddField(GetColumnIndex("LimitMinute"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32LimitMinute));
		AddField(GetColumnIndex("LimitLevel"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterLimitLevelMin));
		AddField(GetColumnIndex("LimitLevelMax"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterLimitLevelMax));
		AddField(GetColumnIndex("LimitIndex"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterLimitBossIndex));
		AddField(GetColumnIndex("MaxCount"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32MaxPlayerCount));
		AddField(GetColumnIndex("ExitTime(s)"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ExitTime));
		AddField(GetColumnIndex("WarpX"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32WarpX));
		AddField(GetColumnIndex("WarpY"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32WarpY));
		AddField(GetColumnIndex("HPWeight"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32HpWeight));
		AddField(GetColumnIndex("ExitMapIndex"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ReturnMapIndex));
		AddField(GetColumnIndex("ExitWarpX"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ReturnXPos));
		AddField(GetColumnIndex("ExitWarpY"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ReturnYPos));

		SetKeyField(0);


		LoadCSVFile(szFile);

		Close();
		return true;
	}

```

</details>

### 조현진 선임

#### 천상비2M 이벤트 구조 개선
`Cursor AI`를 활용하여 기존 이벤트 구조의 문제점을 파악하고 구조 개선

<details>
<summary>기존 이벤트 구조의 문제</summary>

- **1. 새로운 이벤트 추가 시 수정해야 할 곳들 (`최소 10개 파일을 수정`)**
    
    ```cpp
    // 새로운 "시즌패스 이벤트" 추가 시:
    
    // 1. EventManager.h에 멤버 변수 추가
    CSeasonPassEvent _seasonPassEvent;  // 새로 추가
    
    // 2. EventManager.cpp의 ReloadData() 함수에 case 추가
    case ENUM_CSV_1003B2M_SeasonPassEventInfo:
    {
        g_CSVFile_1003B2M_SeasonPassEventInfo.LoadDataFile();
        LoadSeasonPassRewardData();  // 새로 추가
    }
    break;
    
    // 3. LoadSeasonPassRewardData() 함수 추가
    void CEventManager::LoadSeasonPassRewardData()
    {
        // 새로운 로드 로직 구현
    }
    
    // 4. LoadEventInfo() 함수에 switch case 추가
    switch (pEventData->i32Type)
    {
        // ... 기존 case들 ...
        case ENUM_EVENT_TYPE::EVENT_SEASON_PASS:
            _seasonPassEvent.SetEventData(stEventInfo);  // 새로 추가
            break;
    }
    
    // 5. SP_EVENT_LIST 패킷에 필드 추가
    struct SP_EVENT_LIST
    {
        // ... 기존 필드들 ...
        EventInfo _SeasonPassInfo;  // 새로 추가
        EventInfo2 _SeasonPassRewardItemList[MAX_SEASON_PASS_EVENT];
    };
    
    // 6. 패킷 처리 함수 추가
    void CEventManager::ProcessSeasonPassRequest(CUnitPC* pPC, BYTE* pPacket)
    {
        // 새로운 패킷 처리 로직
    }
    
    // 7. CSV 파일 헤더 추가
    #include "CSVFile_1003B2M_SeasonPassEventInfo.h"
    
    // 8. CSV 파일 생성
    // CSVFile_1003B2M_SeasonPassEventInfo.h
    // CSVFile_1003B2M_SeasonPassEventInfo.cpp
    
    // 9. CSV 열거형 추가
    // TIDefine.h에 ENUM_CSV_1003B2M_SeasonPassEventInfo 추가
    
    // 10. 서버툴에 CSV 등록
    // ServerCsvReloadDlg.cpp에 새 CSV 추가
    ```
    
- **2-1. 클래스 파일 하나에 모든 이벤트가 다 모여 있음**
    
    **`하나의 파일 안에서 모든 이벤트 내용을 처리하려고 하니 이벤트가 추가 될 때마다 줄이 계속 늘어난다.`** 
    
    **`이로 인해 이벤트가 늘어날수록 코드 추적에 시간이 소모된다.`**
    
    **예시: EventList.h (유저 이벤트 정보 선언)**
    
    ```cpp
    // 각 이벤트별 유저들이 가지고 있어야 할 정보 List
    
    class CAttendanceSpecialEventList : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
    class CCollectionEventList : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
    class CDrawEventList : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
    class CReturnEvent : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
    class CDayPlayEvent : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
    class CMissionEventList : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
    class CAttendanceEventList : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
    class CBingoEventList : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
    class CStackChargingEventList : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
    class CLevelUpEventList : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
    class CPlayYutEventList : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
    
    class CEventRewardProgress
    {
    public:
    	CEventRewardProgress();
    	~CEventRewardProgress() {};
    
    public:
    	INT32 GetEventType() { return _i32EventType; }
    	virtual UINT32 GetEventUnique() { return _ui32EventUnique; }
    	virtual void Init();
    	void EventSetting(UINT32 ui32EventUnique, INT32 i32EventType);
    	BOOL GetSetting() { return _bSetting; }
    	void Setting() { _bSetting = TRUE; }
    private:
    	BOOL _bSetting;
    	UINT32 _ui32EventUnique;
    	INT32 _i32EventType;
    };
    
    class EventList
    {
    public : 
    	EventList();
    	~EventList() {};
    	
    	UINT32 GetDayPlayTime();
    	
    	void SaveEventProgress(CUnitPC* pPC);
    	void RequestUserList(CUnitPC* pPC, INT32 i32EventUnique = 0);
    
    	void InitDayPlayEvent();
    	void InitDay(CUnitPC* pPC, BOOL bWeek);
    public :
    	void init();
    	
    	void ProcessEventDayInit(CUnitPC* pPC); 
    	void ProcessAttendance(CUnitPC* pPC);		
    	void ProcessNewAttendance(CUnitPC* pPC);	
    	void ProcessReturnAttendance(CUnitPC* pPC);	
    	void ProcessEventAttendance(CUnitPC* pPC);	
    	void ProcessEventAttendanceFree(CUnitPC* pPC);	
    
    	BOOL m_bEventRequest;
    
    	INT32 _i32Ready;
    
    	//신규7일이벤트 
    	CAttendanceSpecialEventList _firstweekEvent;
    
    	//복귀 유저 이벤트 
    	CAttendanceSpecialEventList _ReturnUserEvent;
    
    	//특별 출석 이벤트
    	CAttendanceSpecialEventList _AttendSpecialEvnet;
    
    	//출석이벤트
    	CAttendanceEventList _attendEvent;
    
    	// 누적접속 이벤트 
    	CDayPlayEvent _DayplayEvent;
    
    	//수집이벤트
    	CCollectionEventList _CollectionEvent;
    
    	//미션이벤트
    	CMissionEventList _MissionEventList;
    
    	//빙고이벤트
    	CBingoEventList _BingoEventList;
    
    	//뽑기 이벤트
    	CDrawEventList _DrawEventList;
    
    	//충전 이벤트
    	CStackChargingEventList _StackChargingEventList;
    
    	//레벨업 이벤트
    	CLevelUpEventList _LevelUpEvent;
    
    	// 윷놀이 이벤트
    	CPlayYutEventList _PlayYutEventList;
    
    	//7일 출석 이벤트
    	CAttendanceSpecialEventList _AttendSpecialEvnetFree;
    };
    ```
    
    ---
    
    **예시: EventList.cpp (유저 이벤트 정보 정의)**
    
    ```cpp
    // EventList, 각 이벤트 List 멤버 변수, 함수 정의
    // 조협2M 기준 약 3100줄
    ```
    
- **2-2. 새로운 이벤트 추가 및 기존 이벤트 수정 시 유지보수가 힘듦**
    
    **`Save, Load를 할 때 하나의 함수에서 모든 이벤트가 처리되고 있어서 추적이 힘듦. 2-1과 마찬가지로 이벤트가 늘어날수록 코드 추적에 시간 소모`**
    
    **Event Save**
    
    ```cpp
    // **Game -> Account로 Save 패킷 전송**
    // **실제로 사용하는 이벤트 개수가 10개 미만으로 적게 확인 되는데 Save 함수 하나에 400줄 가량의 코드가 몰려 있다. (주석 포함)**
    void EventList::SaveEventProgress(CUnitPC* pPC)
    {	
    	if (pPC == NULL)
    		return;
    
    	for (auto mapIter = g_EventManager._mapEventData.begin(); mapIter != g_EventManager._mapEventData.end(); ++mapIter)
    	{
    		if (mapIter->second->GetEventType() == ENUM_EVENT_TYPE::EVENT_ATTENDANCE) { // ... Save 패킷 구성 로직 }
    		else if (mapIter->second->GetEventType() == ENUM_EVENT_TYPE::EVENT_DAY_PLAY) { // ... Save 패킷 구성 로직 }
    		else if (mapIter->second->GetEventType() == ENUM_EVENT_TYPE::EVENT_MISSION) { // ... Save 패킷 구성 로직 }
    		else if (mapIter->second->GetEventType() == ENUM_EVENT_TYPE::EVENT_BINGO) { // ... Save 패킷 구성 로직 }
    		else if (mapIter->second->GetEventType() == ENUM_EVENT_TYPE::EVENT_COLLECT) { // ... Save 패킷 구성 로직 }
    		else if (mapIter->second->GetEventType() == ENUM_EVENT_TYPE::EVENT_DRAW) { // ... Save 패킷 구성 로직 }
    		else if (mapIter->second->GetEventType() == ENUM_EVENT_TYPE::EVENT_STACK_CHARGING) { // ... Save 패킷 구성 로직 }
    		else if (mapIter->second->GetEventType() == ENUM_EVENT_TYPE::EVENT_PLAY_YUT) { // ... Save 패킷 구성 로직 }
    	}
    }
    ```
    
    **Event Load**
    
    ```cpp
    // **유저 접속 후 Game -> AccountDB 서버에 정보 요청**
    // **AccountDB에서 DB로드 후 Game서버에 리턴 하는 함수 (약 1000줄)**
    void CGameManager::ON_DCM_LOAD_EVENT_REWARD_PROGRESS(int iClient, WORD wExtraHeader, BYTE* pPacket)
    {
    	// **각 조건 블록에서 프로시저 실행 후 데이터 로드하여 Game서버에 보낼 패킷 구성**
    	if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_DAY_PLAY) {}
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_ATTENDANCE)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_NEWATTENDANCE	|| pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_ATTENDANCE_RETURN)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_SPECIAL_ATTENDANCE)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_MISSION)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_BINGO)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_DRAW)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_COLLECT)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_STACK_CHARGING)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_LEVELUP_PACKAGE)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_PLAY_YUT)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_SPECIAL_ATTENDANCE_FREE)
    }
    ```
    
    **AccountDB → Game 로드한 데이터 PC에 세팅**
    
    ```cpp
    void CEventManager::ON_LOAD_USERS_EVENT_DATA(BYTE* pPacket)
    {
    	// **각 조건 블록에서 로드한 데이터 PC에 세팅하는 처리 (약 500줄)**
    	if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_ATTENDANCE)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_NEWATTENDANCE)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_ATTENDANCE_RETURN)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_SPECIAL_ATTENDANCE)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_MISSION)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_BINGO)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_DRAW)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_COLLECT)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_STACK_CHARGING)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_LEVELUP_PACKAGE)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_PLAY_YUT)
    	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_SPECIAL_ATTENDANCE_FREE)
    }
    ```
    
- **3. 기존 코드의 중복 문제 (`예시: LoadEventInfo()`)**
    
    ```cpp
    void CEventManager::LoadEventInfo()
    {
        _CSV_1003B2M_EVENT_DATA* pEventData = g_CSVFile_1003B2M_EventInfo.GetFirstRecordData();
        
        while (pEventData)
        {
            EventInfoData stEventInfo;
            // ... 공통 데이터 설정 ...
            
            switch (pEventData->i32Type)
            {
            case ENUM_EVENT_TYPE::EVENT_ATTENDANCE:
                _attendanceEvent.SetEventData(stEventInfo);
                break;
            case ENUM_EVENT_TYPE::EVENT_COLLECTION:
                _CollectEvent.SetEventData(stEventInfo);
                break;
            case ENUM_EVENT_TYPE::EVENT_MISSION:
                _MissionEvent.SetEventData(stEventInfo);
                break;
            case ENUM_EVENT_TYPE::EVENT_BINGO:
                _BingoEvent.SetEventData(stEventInfo);
                break;
            case ENUM_EVENT_TYPE::EVENT_DRAW:
                _DrawEvent.SetEventData(stEventInfo);
                break;
            case ENUM_EVENT_TYPE::EVENT_STACK_CHARGE:
                _StackChargeEvent.SetEventData(stEventInfo);
                break;
            case ENUM_EVENT_TYPE::EVENT_LEVEL_UP:
                _levelUpEvent.SetEventData(stEventInfo);
                break;
            case ENUM_EVENT_TYPE::EVENT_PLAY_YUT:
                _PlayYutEvent.SetEventData(stEventInfo);
                break;
            // 새로운 이벤트 추가 시마다 case 추가 필요!
            }
            
            pEventData = g_CSVFile_1003B2M_EventInfo.GetNextRecordData();
        }
    }
    ```
    
- **4. 문서 하나에 모든 이벤트를 같이 사용함**
    
    **`1003bM_EventInfo.csv`**
    
    - 이벤트 별로 사용하는 열이 있고, 사용하지 않는 열이 있음
    
    ![image.png](attachment:11f4a158-f8fc-44e8-bf62-31843ef48cb9:image.png)
    
    **`1003bM_EventReward.csv`** 
    
    - 이벤트 별로 사용하는 열이 있고, 사용하지 않는 열이 있음
    - 이벤트 별로 사용하는 열의 내용이 모두 다름 (이벤트마다 문서를 새로 만드는게 아니라 이 문서에 필요한 모든 값들을 넣음)
    - 해당 이벤트 기획 담당자가 아니면 이벤트 추가하기 어려움
    
    ![image.png](attachment:b8de4dc0-67e6-424f-b099-5bda31b383f1:image.png)



</details>
<details>
<summary>이벤트 개선된 구조</summary>

- **생성 흐름도 (EventV2Manager - 이벤트 데이터 객체 생성, 데이터 로드)**
    
    ```cpp
    1. EventV2Manager::Initialize()
        ↓
    2. CEventV2Manager::RegisterV2EventDatas()
        ↓
    3. CEventV2Manager::RegisterEvent<EventT>(ENUM_EVENT_TYPE) 이벤트 등록 함수 호출
        ↓
    4. new CAttendanceEventV2Data(eventType) 파생 클래스 생성자 호출
        ↓
    5. CAttendanceEventV2Data 파생 클래스 생성자 시작
        ↓
    6. CAttendanceEventV2Data(ENUM_EVENT_TYPE eventType) : CEventDataV2(eventType) 베이스 클래스 생성자 시작
        ↓
    8. CEventDataV2 베이스 클래스 생성자 완료
        ↓
    10. CAttendanceEventV2Data 파생 클래스 생성자 완료
        ↓
    3 ~ 10 이벤트 개수 만큼 반복 - _mapEventV2Data멤버 변수에 이벤트 클래스 캐싱
        ↓
    11. CEventV2Manager::RegisterV2EventDatas() 함수 완료
        ↓
    12. EventV2Manager::Initialize() - LoadAllEventDataFromCSV() 데이터 로드 함수 호출
        ↓
    13. RegisterV2EventDatas() 함수를 통해 생성된 _mapEventV2Data<ENUM_EVENT_TYPE, CEventDataV2*>에 접근하여 LoadFromCSV() 호출
    void CEventV2Manager::LoadAllEventDataFromCSV()
    {
        for (auto& pair : _mapEventV2Data)
        {
            if (pair.second)
            {
                if (pair.second->LoadFromCSV() == FALSE) {... 실패 메시지 출력}
            }
        }
    }
        ↓
    14. CEventDataV2(베이스 클래스)의 LoadFromCSV()는 순수가상함수라 이벤트별 파생 클래스의 함수를 호출 하게 된다.
    BOOL CAttendanceEventV2Data::LoadFromCSV()
    {
        // 1. 출석 이벤트 기본 정보 로드(베이스 클래스 함수 호출)
        if (CEventDataV2::LoadBasicEventDataFromCSV() == FALSE)
        {
            return FALSE;
        }
    
        // 2. 출석 이벤트 고유 정보 로드
        if (LoadEventSpecificDataFromCSV() == FALSE)
        {
            return FALSE;
        }
    
        SetDataSet(TRUE);
        ActivateEvent();
    
        return TRUE;
    }
        ↓
    15. 등록된 모든 이벤트 데이터 로드 이후 EventV2Manager::Initialize() 종료
    ```
    
- **생성 흐름도 (EventV2List - 이벤트 리스트 객체 생성: 이벤트 별 유저 진행 정보)**
    
    ```cpp
    1. CEventV2List::CEventV2List()
        ↓
    2. RegisterEventList(EVENT_V2_ATTENDANCE, new CAttendanceEventV2List(EVENT_V2_ATTENDANCE));
        ↓
    3. new CAttendanceEventV2List(eventType) 파생 클래스 생성자 호출
        ↓
    4. CAttendanceEventV2List(eventType) 파생 클래스 생성자 시작
        ↓
    5. CAttendanceEventV2List(eventType)
        : CEventV2ListBase<CAttendanceEventV2Data, stAttendance28ProgressV2Data>(eventType) 베이스 클래스 생성자 시작
        ↓
    6. CEventV2ListBase(ENUM_EVENT_TYPE eventType) 베이스 클래스 생성자 완료
        ↓
    7. CAttendanceEventV2List(eventType) 파생 클래스 생성자 완료
        ↓
    8. CEventV2List::RegisterEventList(ENUM_EVENT_TYPE eventType, IEventV2ListBase* pEventList) 함수 시작
        ↓
    9. map<ENUM_EVENT_TYPE, IEventV2ListBase*> _mapEventLists 멤버 변수에 등록
    void CEventV2List::RegisterEventList(ENUM_EVENT_TYPE eventType, IEventV2ListBase* pEventList)
    {
        if (!pEventList)
        {
            return;
        }
        
        if (g_EventV2Manager.IsEventActive(eventType) == FALSE)
        {
            // 활성화 되지 않은 이벤트는 리스트에 추가하지 않는다. 호출할 때 동적 할당한 메모리 해제
            // 매니저에서 V2 이벤트만 등록 가능하도록 예외처리 해뒀기 때문에 V2 범위가 아니면 여기서 걸러짐
            delete pEventList;
            printf("[EventV2List] Event %d is not active, skipping registration\n", eventType);
            return;
        }
    
        // 기존 이벤트 리스트가 있다면 해제
        auto it = _mapEventLists.find(eventType);
        if (it != _mapEventLists.end())
        {
            if (it->second)
            {
                delete it->second;
            }
        }
    
        // 새 이벤트 리스트 등록
        _mapEventLists[eventType] = pEventList;
    }
        ↓
    10. 2 ~ 9 이벤트 개수 만큼 반복(_mapEventLists에 유저 이벤트별 진행 정보 클래스 캐싱) 후 EventV2List() 생성자 종료
    ```


</details>
