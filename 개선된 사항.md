### 1. User 객체 관련
- 기존 하드코딩되어있던 아이템옵션 & 밸런스 적용부분을 문서로 바꾸었으며, 적용에 있어 불필요하게 나뉘어져 있던 배열들을 통일시켰음.
- 재귀함수를 타던 레벨업 로직들에 대해 for문으로 단순화를 시켰으며, 경험치 관련 하드코딩으로 상단을 막아두었던거에 대해 문서상 데이터 유무로 다음레벨 체크로 변경
- Attack Animation관련 문서를 읽어 랜덤하게 방송처리하게 변경

### 2. 아이템 인포에 장비옵션 & 강화옵션 들어가 있던거 분할
- 인포에 대해 정확한 기능 분리를 하여 작업이 쉽게 만듬.
- 기존 강화 단계검증을 하드코딩으로 하였으나 해당 아이템 인덱스로 검증
- Iteminfo.csv의 기능은 순수하게 아이템만 저장하고 기존 하드코딩된 스탯은 전부 개별문서화 하였음.

### 3. 스킬
- 기존 스킬 옵션에 버프 옵션이 혼선되어 있던것을 이펙트로 바꾸며, 아이템 옵션과 통일
- 임시적으로 사용가능

### 4. CashDB로직 최적화
- 복잡했던 로직들을 단순화
- 검증에 대해서는 더 빠듯하게 하게 변경
- 클래스
<details> 
<summary>캐시로직 분할화 코드</summary>
  
```ruby

class ICashManager
{
public:
    virtual ~ICashManager() {}
    virtual void ON_DSM_MSG(DSP_REPLY_CASH* pMsg) = 0;

    // 타입별 Consume/Deposit을 위한 가상 함수 추가
    virtual BOOL ConsumeGeneric(ENUM_COST_TYPE eCostType, int enumValue,CashDetailDataInfo* detailData) = 0;
    virtual BOOL DepositGeneric(ENUM_COST_TYPE eCostType, int enumValue,CashDetailDataInfo* detailData) = 0;
};

template<typename CONSUME_T, typename DEPOSIT_T>
class CCash : public ICashManager
{
public:
   // virtual CCash(ENUM_CASH_TABLE_TYPE eType) { eCashTableType = eType; }

    virtual BOOL Consume(ENUM_COST_TYPE eCostType, CONSUME_T eCashType,CashDetailDataInfo* detailData) = 0;
    virtual BOOL Deposit(ENUM_COST_TYPE eCostType, DEPOSIT_T eCashType,CashDetailDataInfo* detailData) = 0;


    // ICashManager 구현
    BOOL ConsumeGeneric(ENUM_COST_TYPE eCostType, int enumValue, CashDetailDataInfo* detailData) override
    {
        return Consume(eCostType, static_cast<CONSUME_T>(enumValue), detailData);
    }

    BOOL DepositGeneric(ENUM_COST_TYPE eCostType, int enumValue, CashDetailDataInfo*  detailData) override
    {
        return Deposit(eCostType, static_cast<DEPOSIT_T>(enumValue), detailData);
    }

protected:
    ENUM_CASH_TABLE_TYPE eCashTableType;


    void GetCashTableTypeString(ENUM_CASH_TABLE_TYPE eType, WCHAR wcTypeStr[MAX_CASHDB_TABLE_STR])
    {
        switch (eType)
        {
        case ENUM_CASH_TABLE_TYPE::TYPE_NONE:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"NONE");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_USER:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"USER");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_USER_TRADE_STORAGE:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"USER_TRADE");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_USER_MAIL:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"USER_MAIL");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_USER_CASH_STORAGE:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"USER_CASH_STORAGE");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_MUNPA:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"MUNPA");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_CASTLE:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"CASTLE");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_TRAININGCENTER:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"TRAININGCENTER");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_GNI_TAX:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"GNI_TAX");
            break;
        default:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"NONE");
            break;
        }
    }




};
#include "CCash.h"
#include "GameManager.h"
#include "UnitPC.h"
class CUserCash : public CCash<USER_CONSUME, USER_DEPOSIT>
{
public:
    CUserCash(ENUM_CASH_TABLE_TYPE eType) { eCashTableType = eType; }; 

	virtual BOOL Consume(ENUM_COST_TYPE eCostType, USER_CONSUME eCashType, CashDetailDataInfo* detailData) override;
	virtual BOOL Deposit(ENUM_COST_TYPE eCostType, USER_DEPOSIT eCashType, CashDetailDataInfo* detailData) override;
	virtual void ON_DSM_MSG(DSP_REPLY_CASH* pMsg) override;

private:
	void UserConsumeCompleate(DSP_REPLY_CASH* pMsg);
	void UserDepositCompleate(DSP_REPLY_CASH* pMsg);



    void GetUserConsumeString(USER_CONSUME eType,
        WCHAR wcTypeStr[MAX_CASHDB_TABLE_STR],
        WCHAR	m_iDetail1_str[MAX_CASHDB_TABLE_STR],
        WCHAR	m_iDetail2_str[MAX_CASHDB_TABLE_STR],
        WCHAR	m_iDetail3_str[MAX_CASHDB_TABLE_STR]
    );
  
    void GetUserDepositString(USER_DEPOSIT eType,
        WCHAR wcTypeStr[MAX_CASHDB_TABLE_STR],
        WCHAR	m_iDetail1_str[MAX_CASHDB_TABLE_STR],
        WCHAR	m_iDetail2_str[MAX_CASHDB_TABLE_STR],
        WCHAR	m_iDetail3_str[MAX_CASHDB_TABLE_STR]
    );


};



```

</details>

기존 : 캐시 습득의 경우 캐시지급에 성공을 해야 아이템 지급하는 구조-> 아이템 지급하다 실패(인벤토리 슬롯 실패 외 없음)->습득 취소
변경 : 아이템 지급을 성공하면 캐시습득을 함. 캐시를 습득하는데 있어, 실패할 가능성이 있는가..? 유저가 로그아웃되어도 다시 접속하면 캐시는 늘어나 있고, 아이템을 먼저지급했기에 문제가 없음.

<img width="709" height="752" alt="image" src="https://github.com/user-attachments/assets/3f5b8a45-980b-4414-a44d-035e82a09120" />

기존 프로젝트 & 더 예전 프로시저(미사용)들과 로직에 대한 정리.

#### 4-2.CahsCheck매니저 사용
 기존 처럼 입력된 값만으로 한곳에서 조사하는 방식이 아닌, 정말로 생산된 금화인지 체크하는 부분을 추가, 사냥하며 얻는 캐시에 대해서는 주간 Maxmum 생산량을 임시 계산하여 비교하여 검사한다.

### 5. Preset 관련 로직 수정
일부 컨텐츠들이 프리셋에 있음에도 여전히 개별적으로 셋팅한 뒤 프리셋으로 바꾸는 로직이 존재하였다. 해당 로직들을 정리하였다.

### 6. 운영자 명령어
<details> 
<summary>명령어 분할화 코드</summary>

기능 구현
```ruby

stGMResult Handle_SetLevel(CUnitPC& refPC, const stGMRequest& refRequest)
{
    refPC.LevelTest(refRequest._i32Index);
    return stGMResult(0,refRequest._i32Index);
}

stGMResult Handle_SetStat(CUnitPC& refPC, const stGMRequest& refRequest)
{
    stGMResult stResult;
    if (refRequest._eType == GM_MSG_TYPE::SET_STAT)
    {
        GM_MSG_TYPE eType = static_cast<GM_MSG_TYPE>(refRequest._i32Index);
        stResult._i32FailCode = refPC.SetCommandStat(eType, refRequest._i32Value1);
    }
    else
    {
        stResult._i32FailCode = refPC.SetCommandStat(refRequest._eType, refRequest._i32Index, refRequest._i32Value1);
    }

    return stResult;
}

stGMResult Handle_SetSkill(CUnitPC& refPC, const stGMRequest& refRequest)
{
    const INT32 i32SkillIndex = refRequest._i32Index;
    const INT32 i32SkillLevel = refRequest._i32Value1;

    BOOL bResult = refPC.GetSkillList()->AdminSetSkillLevel(&refPC, i32SkillIndex, i32SkillLevel);

    if (bResult == TRUE)
    {
        SP_SKILL_UPGRADE sendSkill;
        sendSkill.iResultSkillLevel = i32SkillLevel;
        sendSkill.iSkillID = i32SkillIndex;
        sendSkill.iResult = 0;
        refPC.Write((BYTE*)&sendSkill, sizeof(SP_SKILL_UPGRADE));
    }

    return stGMResult((bResult == TRUE ? 0 : 1), 0);
}

stGMResult Handle_GetAllSkill(CUnitPC& refPC, const stGMRequest& refRequest)
{
    UINT8 ui8SkillLevel = refRequest._i32Index >= MAX_SKILL_COUNT2 ? MAX_SKILL_COUNT2 - 1 : refRequest._i32Index;
    ENUM_ALL_ERROR eResult = refPC.GetSkillList()->GMGetAllSkill(&refPC, ui8SkillLevel);
    return stGMResult(eResult, 0);
}

stGMResult Handle_UpdateGMAbility(CUnitPC& refPC, const stGMRequest& refRequest)
{
    refPC.UpdateGMMsgAbility(refRequest._i32Index, refRequest._i32Value1);
    return stGMResult();
}

```
핸들러 등록

```ruby

void RegisterGMCommands_Balance(GMCommandDispatcher& refDispatcher)
{
    static const stGMCommand stCommands[] =
    {
        // stGMCommandMeta(운영자 여부(1), 더미 여부(2), 생존(3), 맵 데이터(4), 테스트 서버만 허용(5))
        stGMCommand{GM_MSG_TYPE::INIT_CHARACTER, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, TRUE), Handle_InitCharacter },
        stGMCommand{GM_MSG_TYPE::SET_LEVEL, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, TRUE), Handle_SetLevel },
        stGMCommand{GM_MSG_TYPE::SET_STR, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, TRUE), Handle_SetStat },
        stGMCommand{GM_MSG_TYPE::SET_DEX, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, TRUE), Handle_SetStat },
        stGMCommand{GM_MSG_TYPE::SET_CON, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, TRUE), Handle_SetStat },
        stGMCommand{GM_MSG_TYPE::SET_JOB, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, TRUE), Handle_SetStat },
        stGMCommand{GM_MSG_TYPE::SET_STAT, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, TRUE), Handle_SetStat },
        stGMCommand{GM_MSG_TYPE::SET_SKILL, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, TRUE), Handle_SetSkill },
        stGMCommand{GM_MSG_TYPE::GET_ALL_SKILL, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, TRUE), Handle_GetAllSkill },
        stGMCommand{GM_MSG_TYPE::UPDATE_GM_ABILITY, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, FALSE), Handle_UpdateGMAbility },
    };

    const size_t LoopCount = sizeof(stCommands) / sizeof(stGMCommand);
    for (size_t i = 0; i < LoopCount; ++i)
    {
        const stGMCommand& stCmd = stCommands[i];
        refDispatcher.Register(stCmd._eType, stCmd._stMeta, stCmd._funcHandler);
    }
}
```
실행

```ruby
stGMResult GMCommandDispatcher::Execute(CUnitPC& refPC, const stGMRequest& refRequest) const
{
    auto iter = _mapCommandTable.find(refRequest._eType);
    if (iter == _mapCommandTable.end())
    {
        // 등록되지 않은 명령
        return stGMResult(ENUM_ALL_ERROR_FAILED, 0);
    }

    const stGMCommandEntry& refEntry = iter->second;
    const stGMCommandMeta& refMeta = refEntry._stMeta;

    // 계정 권한 검사
    if (!IsAllowedAccount(refPC, refMeta))
    {
        return stGMResult(ENUM_ALL_ERROR_FAILED, 0);
    }

    // 생존/워프 상태 조건
    if (refMeta._bNeedAlive && (!refPC.GetAlive() || refPC.m_bWARP_PENDING == TRUE))
    {
        return stGMResult(ENUM_ALL_ERROR_FAILED, 0);
    }

    // 맵 필요
    if (refMeta._bNeedMap && refPC.GetCurrentMap() == NULL)
    {
        return stGMResult(ENUM_ALL_ERROR_FAILED, 0);
    }

    // 테스트 서버 전용
    if (refMeta._bOnlyTestServer && g_INIFile_Setting.m_iTestserver != 1)
    {
        return stGMResult(ENUM_ALL_ERROR_FAILED, 0);
    }

    // 실제 처리
    return refEntry._funcHandler(refPC, refRequest);
}
```
</details>

기존 Enum으로 하드코딩되어있던 부분들을 세부적으로 분할하여 작업하였다.



### 7. 로그 매니저
<details> 
<summary>선언부 </summary>

```ruby
class LogEntry
{
private:
	std::map<std::wstring, std::wstring> m_fields;


public:
	LogEntry& AddFields(const wstring& wstr, const INT32& i32Value)
	{
		m_fields.insert(pair<wstring, wstring>(wstr, to_wstring(i32Value)));
		return *this;
	}
	LogEntry& AddFields(const wstring& wstr, const DWORD& dwValue)
	{
		m_fields.insert(pair<wstring, wstring>(wstr, to_wstring(dwValue)));
		return *this;
	}
	LogEntry& AddFields(const wstring& wstr, const INT64& i64Value)
	{
		m_fields.insert(pair<wstring, wstring>(wstr, to_wstring(i64Value)));
		return *this;
	}
	LogEntry& AddFields(const wstring& wstr, const UINT64& i64Value)
	{
		m_fields.insert(pair<wstring, wstring>(wstr, to_wstring(i64Value)));
		return *this;
	}
	LogEntry& AddFields(const wstring& wstr, const wstring& wsvalue)
	{
		m_fields.insert(pair<wstring, wstring>(wstr, wsvalue));
		return *this;
	}

	LogEntry& PCFields(CUnitPC& refPc, wstring AddFieldCol = L"");
	LogEntry& UnitFields(CUnit& refUnit, wstring AddFieldCol = L"");
	LogEntry& MunpaFields(CMunpa& refMunpa, wstring AddFieldCol = L"");
	LogEntry& ItemFields(CItem& refItem, wstring AddFieldCol = L"");
	LogEntry& TypeFields(INT32 i32Type, wstring wsTypeStr);

	std::map<std::wstring, std::wstring>* GetField() { return &m_fields; }
};

매니저에 LogEntry사용을 위한 함수 추가
void CLogManager::SendLog(char LogTable[MAX_MONGO_COLECTION_NAME], LogEntry& Log)
{
	Log.AddFields(L"groupnum", to_wstring(g_INIFile_Server.m_iServerGroupID));

	SendLogServer(LogTable, Log.GetField());
}

```
</details>


<details> 
<summary>호출부 </summary>

```ruby
CLogManager::SendLog("char_repair_logs",
				LogEntry()
				.PCFields(*_pPC)
				.TypeFields(LOG_TYPE::CHAR_RESTORE_EXP, L"CHAR_RESTORE_EXP")
				.AddFields(L"repairtype", 1)
				.AddFields(L"repairtypestr", L"MONEY")
				.AddFields(L"beforeMoney", iLogBeforMoney)
				.AddFields(L"afterMoney", _pPC->GetMoney())
				.AddFields(L"beforeexp", iLogBeforExp)
				.AddFields(L"afterexp", _pPC->GetExp())
				.AddFields(L"cost", LoseExpList[i].iRubyCost)
			);
```

<img width="1408" height="673" alt="image" src="https://github.com/user-attachments/assets/18a84bad-ca4d-411a-80d8-6efc08b153c2" />
좌 - 변경전 / 우 - 변경 후

</details>

기존 로그가 함수식으로 여러 필드를 개별적으로 입력하는 방식이었으면, 공통된 부분에 대해서는 모듈화를 하여 호출부에서 필요한 부분만 추가하는 식으로 변경하였다.\
해당 모듈화에 따라 의견차이가 있기는 하지만, 신규 개발 프로젝트 인원끼리 합의한 결과 로그를 남기는 곳에서 직관적으로 남기는게 확장성에 더 쉬울것으로 생각된다 하여 방식을 변경하였다.

### 8. 스킬
- 기존 로직
1) 디버프 스킬공격
2) 성공 -> 스킬 전용 옵션을 적용 -> 버프가있으면 버프를 건다
3) 능력치 적용 단계에서 스킬 전용 옵션을 아이템 옵션으로 치환하여 능력치에 더해준다.( 그러므로 SKO-> ITO(아이템 옵션) 환산 과정에서 치환식에에 없는 SKO옵션 버프의 능력치값은 Balance에 더해주지 않는다. -> Buff를 적용하는 과정에서 해당 버프가 스페셜스킬 버프인지, 일반버프인지에 따라 해당 치환식 적용 유무를 따짐
*** 결론 : SkillInfo.csv에는 SKO를 쓰지만, BuffInfo.csv에는 ITO,SKO 둘다 입력을 하여 사용하고있음.
<details> 
<summary>기존 옵션 적용부 </summary>

```ruby
  if ((*iter)->GetBuffType() == BUFF_TYPE::BUFF_TYPE_SKILL || (*iter)->GetBuffType() == BUFF_TYPE::BUFF_TYPE_SKILL_SPECIAL
				|| (*iter)->IsBuff() == 1)//(*iter)->GetBuffType() == BUFF_TYPE::BUFF_TYPE_DEBUFF)
			{
				for (int j = 0; j < MAX_SKILL_OPTION_COUNT; j++)
				{
					if ((*iter)->GetBuffOption(j) == 0)
					{
						continue;
					}
					g_SkillManager.GetAbility(_Add_Buff_Ability, Increase_Ability, Decrease_Ability, (*iter)->GetBuffOption(j), (*iter)->GetBuffOptionValue(j));
				}
			}
			else
			{
				g_ItemManager.GetAbility(_Add_Buff_Ability, Increase_Ability, Decrease_Ability, (*iter)->GetBuffOption(), (*iter)->GetValue());
			}

```
```ruby
void CSkillManager::GetAbility(INT32* Add_Ability, INT32* Increase_Ability, vector<INT32>* pDecreaseAb, INT32 i32Option, INT32 i32Value)
{
	switch (i32Option)
	{
	case SKILL_OPTION::SKILL_OPTION_NONE: break;
	case SKILL_OPTION::SKO_MELEE_ATTACK_UP: Add_Ability[Add_Ability_Pos::AAP_MELEE_ATTACK] += i32Value; break;		// 4 : 근공 증가
	case SKILL_OPTION::SKO_RANGED_ATTACK_UP: Add_Ability[Add_Ability_Pos::AAP_RANGED_ATTACK] += i32Value; break;	// 5 : 원공 증가
	case SKILL_OPTION::SKO_SORCERY_ATTACK_UP: Add_Ability[Add_Ability_Pos::AAP_SORCERY_ATTACK] += i32Value; break;	// 6 : 도공 증가
	case SKILL_OPTION::SKO_MELEE_DEF_UP: Add_Ability[Add_Ability_Pos::AAP_MELEE_DEF] += i32Value; break;			// 7 : 근방 증가
	case SKILL_OPTION::SKO_RANGED_DEF_UP: Add_Ability[Add_Ability_Pos::AAP_RANGED_DEF] += i32Value; break;			// 8 : 원방 증가
	case SKILL_OPTION::SKO_SORCERY_DEF_UP: Add_Ability[Add_Ability_Pos::AAP_SORCERY_DEF] += i32Value; break;		// 9 : 도방 증가
	case SKILL_OPTION::SKO_MOVE_SPEED_DOWN: Increase_Ability[Increase_Ability_Pos::IAP_MOVE_SPEED_PER] -= i32Value; break;	// 10: 이속 감소
	case SKILL_OPTION::SKO_MOVE_SPEED_UP: Increase_Ability[Increase_Ability_Pos::IAP_MOVE_SPEED_PER] += i32Value; break;	// 11: 이속 증가
	case SKILL_OPTION::SKO_STATE_STR_UP: Add_Ability[Add_Ability_Pos::AAP_STR] += i32Value; break;	// 14 : 힘
	case SKILL_OPTION::SKO_STATE_DEX_UP: Add_Ability[Add_Ability_Pos::AAP_DEX] += i32Value; break;  // 15 : 민첩
	case SKILL_OPTION::SKO_STATE_INT_UP: Add_Ability[Add_Ability_Pos::AAP_INT] += i32Value; break;	// 16 : 기력
	case SKILL_OPTION::SKO_STATE_CON_UP: Add_Ability[Add_Ability_Pos::AAP_CON] += i32Value; break;	// 17 : 지력
	//TODO::25.07.28_남일우_스탯변경으로 주석
	//case SKILL_OPTION::SKO_STATE_WIS_UP: Add_Ability[Add_Ability_Pos::AAP_WIS] += i32Value; break;	// 18 : 건강
	//case SKILL_OPTION::SKO_STATE_CHA_UP: Add_Ability[Add_Ability_Pos::AAP_CHA] += i32Value; break;	// 19 : 매력
	case SKILL_OPTION::SKO_HP_UP: Add_Ability[Add_Ability_Pos::AAP_ADD_HP] += i32Value; break;		// 20 : 체력 증가
	case SKILL_OPTION::SKO_MP_UP: Add_Ability[Add_Ability_Pos::AAP_ADD_MP] += i32Value; break;		// 21 : 도력 증가
	case SKILL_OPTION::SKO_ATTACK_SPEED_UP: Add_Ability[Add_Ability_Pos::AAP_ADD_ATTACK_SPEED] += i32Value; break;
	case SKILL_OPTION::SKO_ATTACK_SPEED_DOWN: Add_Ability[Add_Ability_Pos::AAP_ADD_ATTACK_SPEED] -= i32Value; break;
	case SKILL_OPTION::SKO_STOP: Add_Ability[Add_Ability_Pos::AAP_DEBUFF_MOVE_STOP] += i32Value; break;
	case SKILL_OPTION::SKO_USE_MP_DOWN: Add_Ability[Add_Ability_Pos::AAP_MP_CONSUMPTION_REDUCTION] += i32Value; break;
	case SKILL_OPTION::SKO_SHIELD: Add_Ability[Add_Ability_Pos::AAP_SHEILD_ON] += i32Value; break;
	case SKILL_OPTION::SKO_ATTACK_CANCLE: Add_Ability[Add_Ability_Pos::AAP_ATTACK_CANCLE] += i32Value; break;
	case SKILL_OPTION::SKO_INVICIBILITY: Add_Ability[Add_Ability_Pos::AAP_INVICIBILITY] += i32Value; break;				// 37 - 금강 불괴
	case SKILL_OPTION::SKO_DOSIMGYUNG_ON: Add_Ability[Add_Ability_Pos::AAP_DOSIMGYUNG_ON] = 1; break;					// 41 -도심경 온
	case SKILL_OPTION::SKO_NOMAL_EXTRA_ATTACK_PER: Add_Ability[Add_Ability_Pos::AAP_EXTRA_ATTACK_PER] = i32Value; break;	// 42 - 추가타 확률
	case SKILL_OPTION::SKO_NOMAL_ATTACK_UP: Add_Ability[Add_Ability_Pos::AAP_SKILL_NOMAL_ATTACK_UP] += i32Value; break;		// 43 - 일반 공격력 상승
	case SKILL_OPTION::SKO_MELEE_SKILL_DAMAGE_UP: Add_Ability[Add_Ability_Pos::AAP_MELEE_SKILL_DAMAGE] += i32Value; break;		// 47 - 근거리 스킬 데미지 증가
	case SKILL_OPTION::SKO_RANGED_SKILL_DAMAGE_UP: Add_Ability[Add_Ability_Pos::AAP_RANGED_SKILL_DAMAGE] += i32Value; break;	// 48 - 원거리 스킬 데미지 증가
	case SKILL_OPTION::SKO_SORCERY_SKILL_DAMAGE_UP: Add_Ability[Add_Ability_Pos::AAP_SORCERY_SKILL_DAMAGE] += i32Value; break;	// 49 - 도술 스킬 데미지 증가
	case SKILL_OPTION::SKO_MELEE_DEF_DOWN: Add_Ability[Add_Ability_Pos::AAP_MELEE_DEF] -= i32Value; break;				// 51 - 상대방 근거리 방어력 감소	
	case SKILL_OPTION::SKO_RANGED_DEF_DOWN: Add_Ability[Add_Ability_Pos::AAP_RANGED_DEF] -= i32Value; break;			// 52 - 상대방 원거리 방어력 감소
	case SKILL_OPTION::SKO_SORCERY_DEF_DOWN: Add_Ability[Add_Ability_Pos::AAP_SORCERY_DEF] -= i32Value; break;			// 53 - 상대방 도술 방어력 감소
	case SKILL_OPTION::SKO_HP_ITEM_INCREASE: Add_Ability[Add_Ability_Pos::AAP_ADD_HP_RECOVERY] += i32Value; break;		// 55 : HP회복제 효율증가
	case SKILL_OPTION::SKO_MP_ITEM_INCREASE: Add_Ability[Add_Ability_Pos::AAP_ADD_MP_RECOVERY] += i32Value; break;		// 56 : MP회복제 효율증가
	case SKILL_OPTION::SKO_MELEE_DAMAGE_INCREASE: Add_Ability[Add_Ability_Pos::AAP_MELEE_DAMAGE] += i32Value; break; // 59 : 근거리 대미지 증가
	case SKILL_OPTION::SKO_RANGE_DAMAGE_INCREASE: Add_Ability[Add_Ability_Pos::AAP_RANGED_DAMAGE] += i32Value; break; // 60: 원거리 대미지 증가
	case SKILL_OPTION::SKO_SOCERY_DAMAGE_INCREASE: Add_Ability[Add_Ability_Pos::AAP_SORCERY_DAMAGE] += i32Value; break; // 61 : 도술 대미지 증가
	case SKILL_OPTION::SKO_CRITICAL_RATE_INCREASE: Add_Ability[Add_Ability_Pos::AAP_CRITICAL_PERCENT] += i32Value; break; // 62 : 일격필살확률 증가
	case SKILL_OPTION::SKO_INCREASE_EXP: Increase_Ability[Increase_Ability_Pos::IAP_EXP_ADD_PER] += i32Value; break; // 64 : 경험치 획득량 증가
	case SKILL_OPTION::SKO_INCREASE_MONEY: Increase_Ability[Increase_Ability_Pos::IAP_MONEY_ADD_PER] += i32Value; break; // 65 : 엽전 획득량 증가
	case SKILL_OPTION::SKO_DECREASE_WARP_COST: Increase_Ability[Increase_Ability_Pos::IAP_DECREASE_WARP_COST] += i32Value; break; // 66 : 워프 비용감소
	case SKILL_OPTION::SKO_DECREASE_MELEE_ATTACK: Add_Ability[Add_Ability_Pos::AAP_MELEE_ATTACK] -= i32Value; break; // 67 : 근거리 공격력 감소 
	case SKILL_OPTION::SKO_DECREASE_RANGE_ATTACK: Add_Ability[Add_Ability_Pos::AAP_RANGED_ATTACK] -= i32Value; break; // 68 : 원거리 공격력 감소
	case SKILL_OPTION::SKO_DECREASE_SOCERY_ATTACK: Add_Ability[Add_Ability_Pos::AAP_SORCERY_ATTACK] -= i32Value; break; // 69 : 도술 공격력 감소
	case SKILL_OPTION::SKO_HIT_RATE_UP: Add_Ability[Add_Ability_Pos::AAP_ADD_HIT] += i32Value; break; // 70 : 적중률 증가
	case SKILL_OPTION::SKO_PVP_ATTACK_ADD: Add_Ability[Add_Ability_Pos::AAP_ADD_PVP_ATTACK] += i32Value; break; // 71 : PVP 공격력 증가
	case SKILL_OPTION::SKO_PVE_ATTACK_ADD: Add_Ability[Add_Ability_Pos::AAP_ADD_PVE_ATTACK] += i32Value; break; // 72 : PVE 공격력 증가
	case SKILL_OPTION::SKO_PVP_DEF_ADD: Add_Ability[Add_Ability_Pos::AAP_ADD_PVP_DEF] += i32Value; break; // 73 : PVP 방어력 증가
	case SKILL_OPTION::SKO_PVE_DEF_ADD: Add_Ability[Add_Ability_Pos::AAP_ADD_PVE_DEF] += i32Value; break; // 74 : PVE 방어력 증가
	case SKILL_OPTION::SKO_MASS_ADD: Add_Ability[Add_Ability_Pos::AAP_ADD_MASS] += i32Value; break; // 75 : 가방 무게 증가
	case SKILL_OPTION::SKO_STATUS_EFFECT_DEFEND_INCREASE: Increase_Ability[Increase_Ability_Pos::IAP_ADD_STATUS_EFFECT_DEFEND] += i32Value; break; // 76 : 상태 이상 저항
	case SKILL_OPTION::SKO_STIFNESS_MISS_ADD: Add_Ability[Add_Ability_Pos::AAP_ADD_STIFFNESS_MISS] += i32Value; break; // 78 : 경직 회피 증가
	case SKILL_OPTION::SKO_DECREASE_HIT: Add_Ability[Add_Ability_Pos::AAP_ADD_HIT] -= i32Value; break; // 80 : 적중 감소
	case SKILL_OPTION::SKO_DECREASE_MISS: Add_Ability[Add_Ability_Pos::AAP_ADD_MISS] -= i32Value; break; // 81 : 회피 감소
	case SKILL_OPTION::SKO_MELEE_DAMAGE_IGNORE_UP: Add_Ability[Add_Ability_Pos::AAP_MELEE_DAMAGE_IGNORE] += i32Value; break; // 82 - 근거리 대미지 증가 무시 (버프)
	case SKILL_OPTION::SKO_RANGE_DAMAGE_IGNORE_UP: Add_Ability[Add_Ability_Pos::AAP_RANGED_DAMAGE_IGNORE] += i32Value; break; // 83 - 원거리 대미지 증가 무시 (버프)
	case SKILL_OPTION::SKO_SORCERY_DAMAGE_IGNORE_UP: Add_Ability[Add_Ability_Pos::AAP_SORCERY_DAMAGE_IGNORE] += i32Value; break; // 84 - 도술 대미지 증가 무시 (버프)
	case SKILL_OPTION::SKO_MELEE_SKILL_DAMAGE_IGNORE_UP: Add_Ability[Add_Ability_Pos::AAP_MELEE_SKILL_DAMAGE_IGNORE] += i32Value; break; // 85 - 근거리 스킬 대미지 증가 무시 (버프)
	case SKILL_OPTION::SKO_RANGE_SKILL_DAMAGE_IGNORE_UP: Add_Ability[Add_Ability_Pos::AAP_RANGED_SKILL_DAMAGE_IGNORE] += i32Value; break; // 86 - 원거리 스킬 대미지 증가 무시 (버프)
	case SKILL_OPTION::SKO_SORCERY_SKILL_DAMAGE_IGNORE_UP: Add_Ability[Add_Ability_Pos::AAP_SORCERY_SKILL_DAMAGE_IGNORE] += i32Value; break; // 87 - 도술 스킬 대미지 증가 무시 (버프)
	case SKILL_OPTION::SKO_MELEE_DEFENSE_IGNORE_UP: Add_Ability[Add_Ability_Pos::AAP_MELEE_DEFENSE_IGNORE] += i32Value; break; // 88 - 근거리 방어력 무시 (버프)
	case SKILL_OPTION::SKO_RANGE_DEFENSE_IGNORE_UP: Add_Ability[Add_Ability_Pos::AAP_RANGED_DEFENSE_IGNORE] += i32Value; break; // 89 - 원거리 방어력 무시 (버프)
	case SKILL_OPTION::SKO_SORCERY_DEFENSE_IGNORE_UP: Add_Ability[Add_Ability_Pos::AAP_SORCERY_DEFENSE_IGNORE] += i32Value; break; // 90 - 도술 방어력 무시 (버프)
	case SKILL_OPTION::SKO_INCREASE_MISS: Add_Ability[Add_Ability_Pos::AAP_ADD_MISS] += i32Value; break; // 92 - 회피 (버프)
	case SKILL_OPTION::SKO_INCREASE_HORSE_DROP_HIT: Increase_Ability[Increase_Ability_Pos::IAP_HORSE_DROP_HIT_PER] += i32Value; break; // 93 - 낙마 적중 (버프)
	case SKILL_OPTION::SKO_INCREASE_HORSE_DROP_MISS: Increase_Ability[Increase_Ability_Pos::IAP_HORSE_DROP_MISS_PER] += i32Value; break; // 94 - 낙마 회피 (버프)
	case SKILL_OPTION::SKO_INCREASE_CRITICAL_DAMAGE: Add_Ability[Add_Ability_Pos::AAP_CRITICAL_DAMAGE] += i32Value; break; // 97 - 일격 필살 데미지 증가 (버프)
	case SKILL_OPTION::SKO_ATTACK_RANGE_ADD: Add_Ability[Add_Ability_Pos::AAP_ATTACK_RANGE_ADD] += i32Value; break; // 99 - 평타 사거리 증가 (버프)
	case SKILL_OPTION::SKO_SKILL_RANGE_ADD: Add_Ability[Add_Ability_Pos::AAP_SKILL_RANGE_ADD] += i32Value; break; // 100 - 스킬 사거리 증가 (버프)
	default:
		break;
	}
}
```

</details>
