### 1. User Option 문서화
- 기존 하드코딩되어있던 아이템옵션 & 밸런스 적용부분을 문서로 바꿈.

### 2. 아이템 인포에 장비옵션 & 강화옵션 들어가 있던거 분할
- 인포에 대해 정확한 기능 분리를 하여 작업이 쉽게 만듬.
- 기존 강화 단계검증을 하드코딩으로 하였으나 해당 아이템 인덱스로 검증

### 3. 능력치 옵션 적용단계
- 기존 스킬 옵션, 아이템 옵션이 나뉘어져 있었으나, 통일
- ENUM으로 하드코딩되어있던 옵션들을 문서화

### 4. CashDB로직 최적화
- 복잡했던 로직들을 단순화
- 검증에 대해서는 더 빠듯하게 하게 변경
- 클래스
<details> 
<summary>캐시로직 분할화 코드</summary>
  
```ruby

class ICashManager
{
public:
    virtual ~ICashManager() {}
    virtual void ON_DSM_MSG(DSP_REPLY_CASH* pMsg) = 0;

    // 타입별 Consume/Deposit을 위한 가상 함수 추가
    virtual BOOL ConsumeGeneric(ENUM_COST_TYPE eCostType, int enumValue,CashDetailDataInfo* detailData) = 0;
    virtual BOOL DepositGeneric(ENUM_COST_TYPE eCostType, int enumValue,CashDetailDataInfo* detailData) = 0;
};

template<typename CONSUME_T, typename DEPOSIT_T>
class CCash : public ICashManager
{
public:
   // virtual CCash(ENUM_CASH_TABLE_TYPE eType) { eCashTableType = eType; }

    virtual BOOL Consume(ENUM_COST_TYPE eCostType, CONSUME_T eCashType,CashDetailDataInfo* detailData) = 0;
    virtual BOOL Deposit(ENUM_COST_TYPE eCostType, DEPOSIT_T eCashType,CashDetailDataInfo* detailData) = 0;


    // ICashManager 구현
    BOOL ConsumeGeneric(ENUM_COST_TYPE eCostType, int enumValue, CashDetailDataInfo* detailData) override
    {
        return Consume(eCostType, static_cast<CONSUME_T>(enumValue), detailData);
    }

    BOOL DepositGeneric(ENUM_COST_TYPE eCostType, int enumValue, CashDetailDataInfo*  detailData) override
    {
        return Deposit(eCostType, static_cast<DEPOSIT_T>(enumValue), detailData);
    }

protected:
    ENUM_CASH_TABLE_TYPE eCashTableType;


    void GetCashTableTypeString(ENUM_CASH_TABLE_TYPE eType, WCHAR wcTypeStr[MAX_CASHDB_TABLE_STR])
    {
        switch (eType)
        {
        case ENUM_CASH_TABLE_TYPE::TYPE_NONE:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"NONE");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_USER:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"USER");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_USER_TRADE_STORAGE:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"USER_TRADE");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_USER_MAIL:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"USER_MAIL");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_USER_CASH_STORAGE:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"USER_CASH_STORAGE");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_MUNPA:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"MUNPA");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_CASTLE:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"CASTLE");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_TRAININGCENTER:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"TRAININGCENTER");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_GNI_TAX:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"GNI_TAX");
            break;
        default:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"NONE");
            break;
        }
    }




};
#include "CCash.h"
#include "GameManager.h"
#include "UnitPC.h"
class CUserCash : public CCash<USER_CONSUME, USER_DEPOSIT>
{
public:
    CUserCash(ENUM_CASH_TABLE_TYPE eType) { eCashTableType = eType; }; 

	virtual BOOL Consume(ENUM_COST_TYPE eCostType, USER_CONSUME eCashType, CashDetailDataInfo* detailData) override;
	virtual BOOL Deposit(ENUM_COST_TYPE eCostType, USER_DEPOSIT eCashType, CashDetailDataInfo* detailData) override;
	virtual void ON_DSM_MSG(DSP_REPLY_CASH* pMsg) override;

private:
	void UserConsumeCompleate(DSP_REPLY_CASH* pMsg);
	void UserDepositCompleate(DSP_REPLY_CASH* pMsg);



    void GetUserConsumeString(USER_CONSUME eType,
        WCHAR wcTypeStr[MAX_CASHDB_TABLE_STR],
        WCHAR	m_iDetail1_str[MAX_CASHDB_TABLE_STR],
        WCHAR	m_iDetail2_str[MAX_CASHDB_TABLE_STR],
        WCHAR	m_iDetail3_str[MAX_CASHDB_TABLE_STR]
    );
  
    void GetUserDepositString(USER_DEPOSIT eType,
        WCHAR wcTypeStr[MAX_CASHDB_TABLE_STR],
        WCHAR	m_iDetail1_str[MAX_CASHDB_TABLE_STR],
        WCHAR	m_iDetail2_str[MAX_CASHDB_TABLE_STR],
        WCHAR	m_iDetail3_str[MAX_CASHDB_TABLE_STR]
    );


};



```

</details>

기존 : 캐시 습득의 경우 캐시지급에 성공을 해야 아이템 지급하는 구조-> 아이템 지급하다 실패(인벤토리 슬롯 실패 외 없음)->습득 취소
변경 : 아이템 지급을 성공하면 캐시습득을 함. 캐시를 습득하는데 있어, 실패할 가능성이 있는가..? 유저가 로그아웃되어도 다시 접속하면 캐시는 늘어나 있고, 아이템을 먼저지급했기에 문제가 없음.

<img width="709" height="752" alt="image" src="https://github.com/user-attachments/assets/3f5b8a45-980b-4414-a44d-035e82a09120" />

기존 프로젝트 & 더 예전 프로시저(미사용)들과 로직에 대한 정리.
