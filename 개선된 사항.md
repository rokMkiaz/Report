### 1. User 객체 관련
- 기존 하드코딩되어있던 아이템옵션 & 밸런스 적용부분을 문서로 바꾸었으며, 적용에 있어 불필요하게 나뉘어져 있던 배열들을 통일시켰음.
- 재귀함수를 타던 레벨업 로직들에 대해 for문으로 단순화를 시켰으며, 경험치 관련 하드코딩으로 상단을 막아두었던거에 대해 문서상 데이터 유무로 다음레벨 체크로 변경
- Attack Animation관련 문서를 읽어 랜덤하게 방송처리하게 변경

### 2. 아이템 인포에 장비옵션 & 강화옵션 들어가 있던거 분할
- 인포에 대해 정확한 기능 분리를 하여 작업이 쉽게 만듬.
- 기존 강화 단계검증을 하드코딩으로 하였으나 해당 아이템 인덱스로 검증
- Iteminfo.csv의 기능은 순수하게 아이템만 저장하고 기존 하드코딩된 스탯은 전부 개별문서화 하였음.

### 3. 스킬
- 기존 스킬 옵션에 버프 옵션이 혼선되어 있던것을 이펙트로 바꾸며, 아이템 옵션과 통일
- 임시적으로 사용가능

### 4. CashDB로직 최적화
- 복잡했던 로직들을 단순화
- 검증에 대해서는 더 빠듯하게 하게 변경
- 클래스
<details> 
<summary>캐시로직 분할화 코드</summary>
  
```ruby

class ICashManager
{
public:
    virtual ~ICashManager() {}
    virtual void ON_DSM_MSG(DSP_REPLY_CASH* pMsg) = 0;

    // 타입별 Consume/Deposit을 위한 가상 함수 추가
    virtual BOOL ConsumeGeneric(ENUM_COST_TYPE eCostType, int enumValue,CashDetailDataInfo* detailData) = 0;
    virtual BOOL DepositGeneric(ENUM_COST_TYPE eCostType, int enumValue,CashDetailDataInfo* detailData) = 0;
};

template<typename CONSUME_T, typename DEPOSIT_T>
class CCash : public ICashManager
{
public:
   // virtual CCash(ENUM_CASH_TABLE_TYPE eType) { eCashTableType = eType; }

    virtual BOOL Consume(ENUM_COST_TYPE eCostType, CONSUME_T eCashType,CashDetailDataInfo* detailData) = 0;
    virtual BOOL Deposit(ENUM_COST_TYPE eCostType, DEPOSIT_T eCashType,CashDetailDataInfo* detailData) = 0;


    // ICashManager 구현
    BOOL ConsumeGeneric(ENUM_COST_TYPE eCostType, int enumValue, CashDetailDataInfo* detailData) override
    {
        return Consume(eCostType, static_cast<CONSUME_T>(enumValue), detailData);
    }

    BOOL DepositGeneric(ENUM_COST_TYPE eCostType, int enumValue, CashDetailDataInfo*  detailData) override
    {
        return Deposit(eCostType, static_cast<DEPOSIT_T>(enumValue), detailData);
    }

protected:
    ENUM_CASH_TABLE_TYPE eCashTableType;


    void GetCashTableTypeString(ENUM_CASH_TABLE_TYPE eType, WCHAR wcTypeStr[MAX_CASHDB_TABLE_STR])
    {
        switch (eType)
        {
        case ENUM_CASH_TABLE_TYPE::TYPE_NONE:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"NONE");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_USER:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"USER");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_USER_TRADE_STORAGE:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"USER_TRADE");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_USER_MAIL:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"USER_MAIL");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_USER_CASH_STORAGE:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"USER_CASH_STORAGE");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_MUNPA:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"MUNPA");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_CASTLE:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"CASTLE");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_TRAININGCENTER:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"TRAININGCENTER");
            break;
        case ENUM_CASH_TABLE_TYPE::TYPE_GNI_TAX:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"GNI_TAX");
            break;
        default:
            wcscpy_s(wcTypeStr, MAX_CASHDB_TABLE_STR, L"NONE");
            break;
        }
    }




};
#include "CCash.h"
#include "GameManager.h"
#include "UnitPC.h"
class CUserCash : public CCash<USER_CONSUME, USER_DEPOSIT>
{
public:
    CUserCash(ENUM_CASH_TABLE_TYPE eType) { eCashTableType = eType; }; 

	virtual BOOL Consume(ENUM_COST_TYPE eCostType, USER_CONSUME eCashType, CashDetailDataInfo* detailData) override;
	virtual BOOL Deposit(ENUM_COST_TYPE eCostType, USER_DEPOSIT eCashType, CashDetailDataInfo* detailData) override;
	virtual void ON_DSM_MSG(DSP_REPLY_CASH* pMsg) override;

private:
	void UserConsumeCompleate(DSP_REPLY_CASH* pMsg);
	void UserDepositCompleate(DSP_REPLY_CASH* pMsg);



    void GetUserConsumeString(USER_CONSUME eType,
        WCHAR wcTypeStr[MAX_CASHDB_TABLE_STR],
        WCHAR	m_iDetail1_str[MAX_CASHDB_TABLE_STR],
        WCHAR	m_iDetail2_str[MAX_CASHDB_TABLE_STR],
        WCHAR	m_iDetail3_str[MAX_CASHDB_TABLE_STR]
    );
  
    void GetUserDepositString(USER_DEPOSIT eType,
        WCHAR wcTypeStr[MAX_CASHDB_TABLE_STR],
        WCHAR	m_iDetail1_str[MAX_CASHDB_TABLE_STR],
        WCHAR	m_iDetail2_str[MAX_CASHDB_TABLE_STR],
        WCHAR	m_iDetail3_str[MAX_CASHDB_TABLE_STR]
    );


};



```

</details>

기존 : 캐시 습득의 경우 캐시지급에 성공을 해야 아이템 지급하는 구조-> 아이템 지급하다 실패(인벤토리 슬롯 실패 외 없음)->습득 취소
변경 : 아이템 지급을 성공하면 캐시습득을 함. 캐시를 습득하는데 있어, 실패할 가능성이 있는가..? 유저가 로그아웃되어도 다시 접속하면 캐시는 늘어나 있고, 아이템을 먼저지급했기에 문제가 없음.

<img width="709" height="752" alt="image" src="https://github.com/user-attachments/assets/3f5b8a45-980b-4414-a44d-035e82a09120" />

기존 프로젝트 & 더 예전 프로시저(미사용)들과 로직에 대한 정리.

### 5. Preset 관련 로직 수정
일부 컨텐츠들이 프리셋에 있음에도 여전히 개별적으로 셋팅한 뒤 프리셋으로 바꾸는 로직이 존재하였다. 해당 로직들을 정리하였다.

### 6. 운영자 명령어
<details> 
<summary>명령어 분할화 코드</summary>

기능 구현
```ruby

stGMResult Handle_SetLevel(CUnitPC& refPC, const stGMRequest& refRequest)
{
    refPC.LevelTest(refRequest._i32Index);
    return stGMResult(0,refRequest._i32Index);
}

stGMResult Handle_SetStat(CUnitPC& refPC, const stGMRequest& refRequest)
{
    stGMResult stResult;
    if (refRequest._eType == GM_MSG_TYPE::SET_STAT)
    {
        GM_MSG_TYPE eType = static_cast<GM_MSG_TYPE>(refRequest._i32Index);
        stResult._i32FailCode = refPC.SetCommandStat(eType, refRequest._i32Value1);
    }
    else
    {
        stResult._i32FailCode = refPC.SetCommandStat(refRequest._eType, refRequest._i32Index, refRequest._i32Value1);
    }

    return stResult;
}

stGMResult Handle_SetSkill(CUnitPC& refPC, const stGMRequest& refRequest)
{
    const INT32 i32SkillIndex = refRequest._i32Index;
    const INT32 i32SkillLevel = refRequest._i32Value1;

    BOOL bResult = refPC.GetSkillList()->AdminSetSkillLevel(&refPC, i32SkillIndex, i32SkillLevel);

    if (bResult == TRUE)
    {
        SP_SKILL_UPGRADE sendSkill;
        sendSkill.iResultSkillLevel = i32SkillLevel;
        sendSkill.iSkillID = i32SkillIndex;
        sendSkill.iResult = 0;
        refPC.Write((BYTE*)&sendSkill, sizeof(SP_SKILL_UPGRADE));
    }

    return stGMResult((bResult == TRUE ? 0 : 1), 0);
}

stGMResult Handle_GetAllSkill(CUnitPC& refPC, const stGMRequest& refRequest)
{
    UINT8 ui8SkillLevel = refRequest._i32Index >= MAX_SKILL_COUNT2 ? MAX_SKILL_COUNT2 - 1 : refRequest._i32Index;
    ENUM_ALL_ERROR eResult = refPC.GetSkillList()->GMGetAllSkill(&refPC, ui8SkillLevel);
    return stGMResult(eResult, 0);
}

stGMResult Handle_UpdateGMAbility(CUnitPC& refPC, const stGMRequest& refRequest)
{
    refPC.UpdateGMMsgAbility(refRequest._i32Index, refRequest._i32Value1);
    return stGMResult();
}

```
핸들러 등록

```ruby

void RegisterGMCommands_Balance(GMCommandDispatcher& refDispatcher)
{
    static const stGMCommand stCommands[] =
    {
        // stGMCommandMeta(운영자 여부(1), 더미 여부(2), 생존(3), 맵 데이터(4), 테스트 서버만 허용(5))
        stGMCommand{GM_MSG_TYPE::INIT_CHARACTER, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, TRUE), Handle_InitCharacter },
        stGMCommand{GM_MSG_TYPE::SET_LEVEL, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, TRUE), Handle_SetLevel },
        stGMCommand{GM_MSG_TYPE::SET_STR, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, TRUE), Handle_SetStat },
        stGMCommand{GM_MSG_TYPE::SET_DEX, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, TRUE), Handle_SetStat },
        stGMCommand{GM_MSG_TYPE::SET_CON, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, TRUE), Handle_SetStat },
        stGMCommand{GM_MSG_TYPE::SET_JOB, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, TRUE), Handle_SetStat },
        stGMCommand{GM_MSG_TYPE::SET_STAT, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, TRUE), Handle_SetStat },
        stGMCommand{GM_MSG_TYPE::SET_SKILL, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, TRUE), Handle_SetSkill },
        stGMCommand{GM_MSG_TYPE::GET_ALL_SKILL, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, TRUE), Handle_GetAllSkill },
        stGMCommand{GM_MSG_TYPE::UPDATE_GM_ABILITY, stGMCommandMeta(TRUE, TRUE, FALSE, FALSE, FALSE), Handle_UpdateGMAbility },
    };

    const size_t LoopCount = sizeof(stCommands) / sizeof(stGMCommand);
    for (size_t i = 0; i < LoopCount; ++i)
    {
        const stGMCommand& stCmd = stCommands[i];
        refDispatcher.Register(stCmd._eType, stCmd._stMeta, stCmd._funcHandler);
    }
}
```
실행

```ruby
stGMResult GMCommandDispatcher::Execute(CUnitPC& refPC, const stGMRequest& refRequest) const
{
    auto iter = _mapCommandTable.find(refRequest._eType);
    if (iter == _mapCommandTable.end())
    {
        // 등록되지 않은 명령
        return stGMResult(ENUM_ALL_ERROR_FAILED, 0);
    }

    const stGMCommandEntry& refEntry = iter->second;
    const stGMCommandMeta& refMeta = refEntry._stMeta;

    // 계정 권한 검사
    if (!IsAllowedAccount(refPC, refMeta))
    {
        return stGMResult(ENUM_ALL_ERROR_FAILED, 0);
    }

    // 생존/워프 상태 조건
    if (refMeta._bNeedAlive && (!refPC.GetAlive() || refPC.m_bWARP_PENDING == TRUE))
    {
        return stGMResult(ENUM_ALL_ERROR_FAILED, 0);
    }

    // 맵 필요
    if (refMeta._bNeedMap && refPC.GetCurrentMap() == NULL)
    {
        return stGMResult(ENUM_ALL_ERROR_FAILED, 0);
    }

    // 테스트 서버 전용
    if (refMeta._bOnlyTestServer && g_INIFile_Setting.m_iTestserver != 1)
    {
        return stGMResult(ENUM_ALL_ERROR_FAILED, 0);
    }

    // 실제 처리
    return refEntry._funcHandler(refPC, refRequest);
}
```
</details>

기존 Enum으로 하드코딩되어있던 부분들을 세부적으로 분할하여 작업하였다.
