### 남일우
#### 1. 생활 컨텐츠 이식 작업
<details>
<summary>생활</summary>
  
  ```ruby
struct LifeResultData
{
	INT32 _i32ResultItemIndex;
	INT32 _i32Percent;
	INT32 _i32Count;
};


enum LIFE_OBJECT_TYPE
{
	LIFE_DATA_OBJECT_TILE,
	LIFE_DATA_OBJECT_NPC,
	LIFE_DATA_OBJECT_MAX,
};

class CLifeData
{
public:
	CLifeData() {}
	CLifeData(INT32 i32EquipItemIndex) { _i32EquipIndex = i32EquipItemIndex; }

	~CLifeData() {}

	void PushData(INT32 i32ResultItem, INT32 i32Precent, INT32 i32Count);
	INT32 GetResultItem();
	vector<LifeResultData>& GetData() {	return _vResultData;  };

private:
	INT32 _i32EquipIndex;
	vector<LifeResultData> _vResultData;
};

class CLifeManager
{
public:
	CLifeManager() {}
	~CLifeManager() {}

	void Release();
	void LoadData();
	void ReloadLifeInfo();
	void ReloadLifeSujibInfo();
	void ReloadLifeExp();
	void ReloadLifeMonthlyFee();
	void ReloadLifeExpSetting();

	INT32 GetRewardItemIndex(INT32 i32EquipItemIndex);
	INT32 GetRewardItemCountFromIndex(INT32 i32EquipItemIndex,INT32 i32ItemIndex); // 23.10.10 진공 csv 갯수추가
	BOOL LifeAction(INT32 i32Type,CUnitPC* pPC, INT32 i32Direction, BOOL bRelay = FALSE);

	void AddLifeExp(CUnitPC* pPC, INT32 i32LifeType);
	void AddFameExp(CUnitPC* pPC);
	void UpdateLevelByExp(CUnitPC* pPC, INT32 i32LifeType);
	_CSV_1003BM_LIFE_SUJIB_DATA* FindLifeSujibData(INT32 i32LifeType, INT32 i32Level);
	INT32 GetLevelUpExp(INT32 i32LifeType, INT32 i32CurLevel);
	_CSV_1003BM_LIFE_MONTHLY_FEE_DATA* FindLifeMonthlyFeeData(INT32 i32CashStoreIndex);

	void GmSetLifeLevel(CUnitPC* pPC, INT32 i32LifeType, INT32 i32Level);	//운영자 명령어
private:
	map<INT32,CLifeData*> _mapLifeData; // 키값은 아이템 인덱스
	_CSV_1003BM_LIFE_SUJIB_DATA _lifeSujibData[LIFE_DATA_TYPE::LIFE_DATA_TYPE_MAX][MAX_LIFE_LEVEL + 1];	// 수집효과 [생활타입][레벨]
	_CSV_1003BM_LIFE_EXP_DATA _lifeExpData[MAX_LIFE_LEVEL + 1];	//경험치 [레벨]
	map<INT32, _CSV_1003BM_LIFE_MONTHLY_FEE_DATA*> _mapLifeMonthlyFeeData;	//월정액 [캐시스토어idx][월정액data]
	vector<_CSV_1003BM_LIFE_EXP_SETTING_DATA*> _vecLifeExpSettingData;	//명성 구간 별 획득 경험치 계산 상수
};

class CLifeList
{
public:
	CLifeList() { Init(); }
	~CLifeList() {}

	void Init();

	void SetLifeInfo(stLifeInfo* stLifeInfo);
	void SendLifeInfo(CUnitPC* pPC);
	void SaveLifeInfo(CUnitPC* pPC);
	void LifeAbilityUpdate(CUnitPC* pPC, BOOL bSend);

	INT32 GetLevel(INT32 i32LifeType);
	void SetLevel(INT32 i32LifeType, INT32 i32Level);
	INT32 GetExp(INT32 i32LifeType);
	void SetExp(INT32 i32LifeType, INT32 i32Exp);
	void AddExp(INT32 i32LifeType, INT32 i32Exp);

	//월정액
	void SetLifeMonthlyFeeInfo(stLifeMonthlyFeeInfo* stLifeMonthlyFeeInfo);
	void SendLifeMonthlyFeeInfo(CUnitPC* pPC);
	void AddLifeMonthlyFee(CUnitPC* pPC, INT32 i32CashStoreIndex);
	void LifeMonthlyFeeAbilityUpdate(CUnitPC* pPC, BOOL bSend);
	void LoopMonthlyFeeEnd(CUnitPC* pPC);

private:
	stLifeInfo _stLifeInfo[LIFE_DATA_TYPE::LIFE_DATA_TYPE_MAX];
	unordered_map<INT32, INT32> _mapLifeMonthlyFeeInfo;
};

  ```
</details>

<details>
<summary>경맥</summary>
  
  ```ruby
class CUnitPC;
struct GyeongMaekPercentData
{
	INT32 _i32Point;
	INT32 _i32CostType;
	INT32 _i32Percent[MAX_GYEONGMAEK_PER_OPEN];
	INT32 _i32ResetType;
	INT32 _i32ResetCost;
};

struct GyeongMaekPartsData
{
	INT32 _i32Option[MAX_RELLIC_PARTS_OPTION];
	INT32 _i32Value[MAX_RELLIC_PARTS_OPTION];
	INT32 _i32RewardSkillIndex[MAX_JOB_TYPE];
	INT32 _i32ConditionType; // 조건타입
	INT32 _i32ConditionValue; // 조건벨류 
};

class CGyeongMaekManager
{
public:
	CGyeongMaekManager();
	~CGyeongMaekManager() {};
	void LoadData();
	void OnGyeongMaekEnchant(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup);
	//
	void ResetGyeongMaekList(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup);
	//
	void OnCSCouponGyeonMaek(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup);
	//
	void PaybackMaterial(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup);
	//
	void GetAbility(INT32 i32Group, INT32 i32SubGroup, INT32 i32Step,INT32* _Add_Ability, INT32* _Increase_Ability, vector<INT32>* pDecreaseAb);
	//
	BOOL CheckOpenAll(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup);
	INT32 GetRewardSkillIndex(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup);
	void CheckRewardSkillAndOpen(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup,INT32 i32Count);
	//
	BOOL CheckData(INT32 i32Group, INT32 i32SubGroup);
	INT32 GetRewardSkillIndex(INT32 i32Group, INT32 i32SubGroup,INT32 i32Job);

	BOOL CheckGyungmaekSkill(INT32 i32SkillIndex,INT32 i32Job);

	INT32 GetMaxTryCount(INT32 i32Group, INT32 i32Tab);
	void GMGyungmaek(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup, INT32 i32Step);
private:
	GyeongMaekPercentData _stEnchantData[MAX_GYEONGMAEK_GROUP][MAX_GYEONGMAEK_TAB][MAX_GYEONGMAEK_TRY_PER_PAGE];
	GyeongMaekPartsData _stPartsData[MAX_GYEONGMAEK_GROUP][MAX_GYEONGMAEK_TAB][MAX_GYEONGMAEK_PARTS_PER_PAGE];

	set<INT32> _RewardSkillIndex[MAX_JOB_TYPE];
	BOOL bCSCouponUse;
};

extern CGyeongMaekManager g_GyeongMaekManager;


class CUnitPC;
class CGyeongMaekList
{
public:
	CGyeongMaekList();
	~CGyeongMaekList() {};
	void Init();

	void SendGyeongMaekList(CUnitPC* pPC);

	void OpenParts(INT32 i32Group, INT32 i32Tab, INT32 i32PartsIndex);
	void AddEnchantCount(INT32 i32Group, INT32 i32Tab);
	
	void GetList(INT32* pList);
	void SetList(INT32* pList);
	//
	void ResetList();
	void PaybackMaterial(CUnitPC* pPC, INT32 i32Group, INT32 i32Tab);
	void InitResetValue();
	void SetResetValue(INT32 i32Group, INT32 i32Tab);
	//
	void AbilityUpdate(INT32* _Add_Ability, INT32* _Increase_Ability, vector<INT32>* pDecreaseAb);

	INT32 GetEnchantCount(INT32 i32Group, INT32 i32Tab);
	INT32 GetOpenIndex(INT32 i32Group, INT32 i32Tab);

	BOOL GetInitProcess() { return _bInitProcess; }
	void SetInitProcess(BOOL bInit) { _bInitProcess = bInit; }
	//김태수_천장 시스템 추가(경맥)_230424
	void UpCombineCount(CUnitPC* pPC);
	void LoadCombineCount(INT32* i32CombineCount);
	void SaveCombineCount(CUnitPC* pPC);
	void SendCombineCount(CUnitPC* pPC);
	void UseCombineCount(CUnitPC* pPC, INT32 i32Grade); //횟수 사용 및 차감

	INT32 GetOpenGyeongmaekCount();
private:
	INT32 _i32GyeongMaekInfo[MAX_GYEONGMAEK_GROUP][MAX_GYEONGMAEK_TAB][MAX_GYEONGMAEK_PARTS_PER_PAGE]; // 열려있는지 닫혔는지 정보
	INT32 _i32yTryEnchant[MAX_GYEONGMAEK_GROUP][MAX_GYEONGMAEK_TAB]; // 강화횟수 

	BOOL _bInitProcess;
	//김태수_천장 시스템 추가(경맥)_230424
	INT32 _i32CombineCount[COMBINE_COUNT_RANK::COMBINE_MAX]; //횟수
	INT32 _i32CombineRewardCount[COMBINE_COUNT_RANK::COMBINE_MAX]; //1회 보상 필요 횟수

	INT32 _i32InitGroup;
	INT32 _i32InitTab;
};


  ```
</details>


#### 2. CashManager 정리 작업
조선협객전 2M에서 미사용하는 함수들이 많아 정리하였음. 교차검증을 통해 확인 완료

<details>
<summary>기존 코드</summary>

```ruby

class CCashManager
{
public:
	CCashManager();
	bool m_bCash_Purchase[MAX_CASH_SHOP_COUNT];
	list<stCashProcessInfo> _stCashProcessList;
	INT64 _i64CashProcessID;
	map<INT32, queue<stCashTrade*>> _stCashTradeInfoList;
	map<INT32, stCashTrade*> _mapCashTradeInfo;
	INT32 _i32CashInfoUnique;

	static void ON_DSM_CONSUME(BYTE* pPacket);
	static void ON_DSM_CONSUME_SILVER(BYTE* pPacket);
	static void ON_DSM_CONSUME_ETC(BYTE* pPacket);
	static void ON_DSM_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_DEPOSIT_SILVER(BYTE* pPacket);
	static void ON_DSM_DEPOSIT_ETC(BYTE* pPacket);

	static void ON_DSM_CANCEL(BYTE* pPacket);
	static void ON_DSM_BALANCE(BYTE* pPacket);


	static BOOL CONSUME(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, DWORD dwCashUnique, INT32 i32CostType, CUnitPC* pPC, int Price, DWORD dwMemo, WCHAR* pMemo, INT32 i32Type, INT64 i64Bundleunique, cashandtrade* cashtrade = NULL, WCHAR* wSellerName = NULL, DWORD dwSellerAccUnique = 0, int detail1 = 0, int detail2 = 0, int detail3 = 0);
	static BOOL DEPOSIT(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, DWORD dwCashUnique, INT32 i32CostType , CUnitPC* pPC, int Price, DWORD _iProductIdx, WCHAR* pMemo, INT32 i32Type, INT64 _dwProducUnique, cashandtrade* cashtrade = NULL);
	static BOOL CANCEL(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, INT32 i32CostType, DWORD dwAccUnique, DWORD dwCharUnique, DWORD dwFieldUnique, int Price, WCHAR* pMemo, INT64 cashId);
	static BOOL BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, DWORD dwCashUnique, INT32 i32CostType, CUnitPC* pPC);

	static BOOL CONSUME_NEW(ENUM_CASH_TABLE_TYPE eTableType, INT32 i32TradeType, CUnitPC* pPC,DWORD dwMainUnique, DWORD dwSubUnique,INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);
	static BOOL DEPOSIT_NEW(ENUM_CASH_TABLE_TYPE eTableType, INT32 i32TradeType, CUnitPC* pPC, DWORD dwMainUnique, DWORD dwSubUnique, INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);

	static BOOL DEPOSIT_ETCCost(ENUM_CASH_TABLE_TYPE eTableType, INT32 i32CostType, INT32 i32TradeType, CUnitPC* pPC, DWORD dwMainUnique, DWORD dwSubUnique, INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);
	static BOOL CONSUME_ETCCost(ENUM_CASH_TABLE_TYPE eTableType, INT32 i32CostType, INT32 i32TradeType, CUnitPC* pPC, DWORD dwMainUnique, DWORD dwSubUnique, INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);


	//static BOOL CONSUME(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, DWORD dwCashUnique, BOOL bGold, CUnitPC* pPC, int Price, DWORD dwMemo, WCHAR* pMemo, INT32 i32Type, INT64 i64Bundleunique, cashandtrade* cashtrade = NULL, WCHAR* wSellerName = NULL, DWORD dwSellerAccUnique = 0, int detail1 = 0, int detail2 = 0 ,int detail3 = 0);
	//static BOOL DEPOSIT(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, DWORD dwCashUnique,BOOL bGold, CUnitPC* pPC, int Price, DWORD _iProductIdx, WCHAR* pMemo, INT32 i32Type, INT64 _dwProducUnique, cashandtrade* cashtrade = NULL);
	//static BOOL CONSUME(BOOL bGold ,CUnitPC* pPC, int Price, DWORD dwMemo, WCHAR* pMemo, BYTE _Type, INT64 i64Bundleunique, cashandtrade* cashtrade = NULL, WCHAR * wSellerName = NULL, DWORD dwSellerAccUnique = 0 );
	//static BOOL DEPOSIT(BOOL bGold, CUnitPC* pPC, int Price, DWORD _iProductIdx,WCHAR* pMemo, BYTE _Type, INT64 _dwProducUnique, cashandtrade* cashtrade = NULL);
	//static BOOL CANCEL(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, BOOL bGold, DWORD dwAccUnique, DWORD dwCharUnique, DWORD dwFieldUnique, int Price, WCHAR* pMemo, INT64 cashId);
	//static BOOL BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, BOOL bGold, CUnitPC* pPC);

	static BOOL NOT_PC_CONSUME(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, BOOL bGold, DWORD dwAccunique,DWORD dwCharunique, int Price, DWORD dwMemo, WCHAR* pMemo, INT32 i32Type, INT64 i64Bundleunique, cashandtrade* cashtrade = NULL, WCHAR* wSellerName = NULL, DWORD dwSellerAccUnique = 0);
	static BOOL NOT_PC_DEPOSIT(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, BOOL bGold, DWORD dwAccunique, DWORD dwCharunique, int Price, DWORD _iProductIdx, WCHAR* pMemo, INT32 i32Type, INT64 _dwProducUnique, cashandtrade* cashtrade = NULL);
	void SetCashPurchase(char* param, char* productIndex);
	//static void SetSendMsgTypeStr(INT32 i32Type, DCP_REQUEST_CASH* pSendmsg);
	static void SetSendMsgTypeStr(INT32 i32Type, char eTypeStr[CASH_TYPE_TEXT_LENGTH]);

	//거래 진행 차감할곳 , 증감할곳 
	static BOOL CASH_TRADE(ENUM_CASH_TABLE_TYPE eType, ENUM_CASH_TABLE_TYPE eTargetType, DWORD dwMainunique, DWORD dwSubunique, DWORD dwTargetMainUnique,DWORD dwTargetSubUnique,
		INT32 i32Price, INT32 i32TradeType, INT32 i32CashUnique,INT32 i32Detail1, INT32 i32Detail2, INT32 i32TargetDetail1, INT32 i32TargetDetail2);
	//유저 금화 아이템 구매(상점 금화 아이템 구매, 
	static BOOL CASH_USER_BUY(CUnitPC* pPC, INT32 i32ProductID ,INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique, INT32 i32BundleUnique);
	//유저 금화 제외한 기타재화로 아이템 구매
	static BOOL ETCCost_USER_BUY(CUnitPC* pPC, INT32 i32ProductID, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique, INT32 i32BundleUnique,INT32 i32CostType);
	//유저 문파 컨텐츠 이용 (기여)
	static BOOL CASH_USER_MUNPA_USE(CUnitPC* pPC, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	//문파 컨텐츠 이용 (문파 버프 구매 등)
	static BOOL CASH_MUNPA_USE(CUnitPC* pPC, DWORD dwTargetUnique , INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	//거래소 이용
	static BOOL CASH_USER_TRADE(CUnitPC* pPC,DWORD dwSellerUnique, DWORD dwSellerCharunique,INT32 i32TradeIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_USER_TRADE_STORAGE_FIND(CUnitPC* pPC, INT32 i32Price,INT32 i32TradeType, INT32 i32TradeIdx,INT64 i64CashUnique);
	//역참 이용
	static BOOL CASH_STATION_DAY(CUnitPC* pPC,INT32 i32StationIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_CALCULATE_GNI(INT32 i32StationIdx, INT32 i32Value, INT32 i32GinTax, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_CALCULATE_GNI_RETURN(INT32 i32StationIdx, INT32 i32Value, INT32 i32GinTax, DWORD dwReturnMunpaUnique, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_CALCULATE(INT32 i32StationIdx, INT32 i32castleIdx, INT32 i32GinTax,INT32 i32castleTax, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_CALCULATE_RETURN(INT32 i32StationIdx, INT32 i32castleIdx, INT32 i32GinTax, INT32 i32castleTax, DWORD dwReturnMunpaUnique ,INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_USE(CUnitPC* pPC, INT32 i32StationIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_BID_SUCCESS(DWORD dwMunpaUnique, INT32 i32StationIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_BID_FAIL(DWORD dwMunpaUnique, INT32 i32StationIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_MAIL_INPUT(CUnitPC* pPC, DWORD dwMailUnique, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STORAGE_INPUT(CUnitPC* pPC, DWORD dwStorgeIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL ETCCost_MAIL_INPUT(CUnitPC* pPC, DWORD dwMailUnique, INT32 i32CostType, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);

	static BOOL CASH_STATION_OBLATION(CUnitPC* pPC, INT32 i32StationIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);

	// 다이아 가져오기
	static void CASH_BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwMainUnique, DWORD dwSubUnique, CUnitPC* pPC);
	static void WORLD_CASH_BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwMainUnique, DWORD dwSubUnique, CUnitPC* pPC);
	// 기타 재화들 가져오기
	static void ETCCost_BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwMainUnique, DWORD dwSubUnique, CUnitPC* pPC);

	//취소 처리
	static void CASH_ALL_CANCEL(BYTE* pPacket);

	static void ON_DSM_CASH_TRADE(BYTE* pPacket);
	static void ON_DSM_CASH_TRADE_GNI(BYTE* pPacket);
	static void ON_DSM_CASH_TRADE_GNI_RETURN(BYTE* pPacket);
	static void ON_DSM_CASH_TRADE_STORAGE(BYTE* pPacket);
	static void ON_DSM_CASH_CALCULATE(BYTE* pPacket);
	static void ON_DSM_CASH_CALCULATE_RETURN(BYTE* pPacket);
	static void ON_DSM_CASH_ALL_CANCEL(BYTE* pPacket);
	static void ON_DSM_CASH_BALANCE(BYTE* pPacket);

	static void ON_DSM_CONSUME_NEW(BYTE* pPacket);
	static void ON_DSM_DEPOSIT_NEW(BYTE* pPacket);

	static void ON_DSM_ETCCost_TRADE(BYTE* pPacket);
	static void ON_DSM_ETCCost_BALANCE(BYTE* pPacket);
	static void ON_DSM_CONSUME_ETCCost(BYTE* pPacket);
	static void ON_DSM_DEPOSIT_ETCCost(BYTE* pPacket);

	//유저 캐쉬
	static void ON_DSM_USER_CONSUME(BYTE* pPacket);
	static void ON_DSM_USER_CONSUME_SILVER(BYTE* pPacket);
	static void ON_DSM_USER_CONSUME_ETC(BYTE* pPacket);
	static void ON_DSM_USER_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_USER_DEPOSIT_SILVER(BYTE* pPacket);
	static void ON_DSM_USER_DEPOSIT_ETC(BYTE* pPacket);
	static void ON_DSM_USER_CANCEL(BYTE* pPacket);
	static void ON_DSM_USER_BALANCE(BYTE* pPacket);
	
	//문파 캐쉬
	static void ON_DSM_MUNPA_CONSUME(BYTE* pPacket);
	static void ON_DSM_MUNPA_CONSUME_SILVER(BYTE* pPacket);
	static void ON_DSM_MUNPA_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_MUNPA_DEPOSIT_SILVER(BYTE* pPacket);
	static void ON_DSM_MUNPA_CANCEL(BYTE* pPacket);
	static void ON_DSM_MUNPA_BALANCE(BYTE* pPacket);
	
	//성 캐쉬
	static void ON_DSM_CASTLE_CONSUME(BYTE* pPacket);
	static void ON_DSM_CASTLE_CONSUME_SILVER(BYTE* pPacket);
	static void ON_DSM_CASTLE_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_CASTLE_DEPOSIT_SILVER(BYTE* pPacket);
	static void ON_DSM_CASTLE_CANCEL(BYTE* pPacket);
	static void ON_DSM_CASTLE_BALANCE(BYTE* pPacket);
	
	//GNI 세금 -> 빼는 것은 없고 넣는 것만 있다.
	static void ON_DSM_GNI_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_GNI_DEPOSIT_SILVER(BYTE* pPacket);
	static void ON_DSM_GNI_CANCEL(BYTE* pPacket);
	static void ON_DSM_GNI_BALANCE(BYTE* pPacket);
	
	//성 일일 정산 세금
	static void ON_DSM_CASTLE_DAY_CONSUME(BYTE* pPacket);
	static void ON_DSM_CASTLE_DAY_CONSUME_SILVER(BYTE* pPacket);
	static void ON_DSM_CASTLE_DAY_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_CASTLE_DAY_DEPOSIT_SILVER(BYTE* pPacket);
	static void ON_DSM_CASTLE_DAY_CANCEL(BYTE* pPacket);
	static void ON_DSM_CASTLE_DAY_BALANCE(BYTE* pPacket);
	
	//거래소 세금
	static void ON_DSM_TRADE_CONSUME(BYTE* pPacket);
	static void ON_DSM_TRADE_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_TRADE_CANCEL(BYTE* pPacket);
	
	//메일 잔금
	static void ON_DSM_MAIL_CONSUME(BYTE* pPacket);
	static void ON_DSM_MAIL_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_MAIL_CANCEL(BYTE* pPacket);
	
	//역참 잔금
	static void ON_DSM_STATION_CONSUME(BYTE* pPacket);
	static void ON_DSM_STATION_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_STATION_CANCEL(BYTE* pPacket);
	static void ON_DSM_STATION_BALANCE(BYTE* pPacket);
	
	//역참 일일 정산 세금
	static void ON_DSM_STATION_DAY_CONSUME(BYTE* pPacket);
	static void ON_DSM_STATION_DAY_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_STATION_DAY_CANCEL(BYTE* pPacket);
	static void ON_DSM_STATION_DAY_BALANCE(BYTE* pPacket);
	
	//역참 경매
	static void ON_DSM_STATION_BID_CONSUME(BYTE* pPacket);
	static void ON_DSM_STATION_BID_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_STATION_BID_CANCEL(BYTE* pPacket);
	static void ON_DSM_STATION_BID_BALANCE(BYTE* pPacket);

	// 공성 던전 분배
	static void ON_DSM_CASTLE_DISTRIBUTE(BYTE* pPacket);

	stCashProcessInfo* FindCashProcess(DWORD dwID);
	void EraseCashProcess(DWORD dwID);
	INT32 AddCashProcess(INT64* i64Value, INT32 i32Table);
	stCashTrade* GetCashTrade(ENUM_CASH_TRADE_TYPE eCashType);
	void ReturnCashTrade(stCashTrade* pInfo);
	stCashTrade* FindCashTrade(INT32 i32CashUnqiue);
};
```

</details>


<details>
<summary>변경 후</summary>

```ruby
class CCashManager
{
public:
	CCashManager();
	bool m_bCash_Purchase[MAX_CASH_SHOP_COUNT];
	list<stCashProcessInfo> _stCashProcessList;
	INT64 _i64CashProcessID;
	map<INT32, queue<stCashTrade*>> _stCashTradeInfoList;
	map<INT32, stCashTrade*> _mapCashTradeInfo;
	INT32 _i32CashInfoUnique;

	//////////////////////////////////////////////////////
	///				CashDB - > Game					//////
	//////////////////////////////////////////////////////
	static void ON_DSM_CONSUME_NEW(BYTE* pPacket);
	static void ON_DSM_DEPOSIT_NEW(BYTE* pPacket);

	static void ON_DSM_CASH_TRADE(BYTE* pPacket);
	static void ON_DSM_CASH_TRADE_GNI(BYTE* pPacket);
	static void ON_DSM_CASH_TRADE_GNI_RETURN(BYTE* pPacket);
	static void ON_DSM_CASH_TRADE_STORAGE(BYTE* pPacket);

	static void ON_DSM_CASH_CALCULATE(BYTE* pPacket);
	static void ON_DSM_CASH_CALCULATE_RETURN(BYTE* pPacket);

	static void ON_DSM_ETCCost_TRADE(BYTE* pPacket);
	static void ON_DSM_ETCCost_BALANCE(BYTE* pPacket);
	static void ON_DSM_CONSUME_ETCCost(BYTE* pPacket);
	static void ON_DSM_DEPOSIT_ETCCost(BYTE* pPacket);
	//밸런스 반영
	static void ON_DSM_CASH_BALANCE(BYTE* pPacket);
	//취소 처리
	static void ON_DSM_CANCEL(BYTE* pPacket);
	static void CASH_ALL_CANCEL(BYTE* pPacket);
	static void ON_DSM_USER_CANCEL(BYTE* pPacket);
	static void ON_DSM_MUNPA_CANCEL(BYTE* pPacket);

	//////////////////////////////////////////////////////
	///				Game - > CashDB					//////
	//////////////////////////////////////////////////////
	static BOOL CASH_USER_CONSUME_ALLTYPE(ENUM_CASH_TABLE_TYPE eTableType, CASH_TYPE i32TradeType, CUnitPC* pPC,DWORD dwMainUnique, DWORD dwSubUnique,INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);
	static BOOL CASH_USER_DEPOSIT_ALLTYPE(ENUM_CASH_TABLE_TYPE eTableType, CASH_TYPE i32TradeType, CUnitPC* pPC, DWORD dwMainUnique, DWORD dwSubUnique, INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);
	static BOOL DEPOSIT_ETCCost(ENUM_CASH_TABLE_TYPE eTableType, INT32 i32CostType, INT32 i32TradeType, CUnitPC* pPC, DWORD dwMainUnique, DWORD dwSubUnique, INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);
	static BOOL CONSUME_ETCCost(ENUM_CASH_TABLE_TYPE eTableType, INT32 i32CostType, INT32 i32TradeType, CUnitPC* pPC, DWORD dwMainUnique, DWORD dwSubUnique, INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);

	static BOOL CASH_MAIL_INPUT(CUnitPC* pPC, DWORD dwMailUnique, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STORAGE_INPUT(CUnitPC* pPC, DWORD dwStorgeIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL ETCCost_MAIL_INPUT(CUnitPC* pPC, DWORD dwMailUnique, INT32 i32CostType, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);

	//컨텐츠 전용
	//유저 금화 아이템 구매(상점 금화 아이템 구매, 
	static BOOL CASH_USER_BUY(CUnitPC* pPC, INT32 i32ProductID ,INT32 i32Price, CASH_TYPE eTradeType, INT64 i64CashUnique, INT32 i32BundleUnique);
	//유저 금화 제외한 기타재화로 아이템 구매
	static BOOL ETCCost_USER_BUY(CUnitPC* pPC, INT32 i32ProductID, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique, INT32 i32BundleUnique,INT32 i32CostType);
	//유저 문파 컨텐츠 이용 (기여)
	static BOOL CASH_USER_MUNPA_USE(CUnitPC* pPC, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	//문파 컨텐츠 이용 (문파 버프 구매 등)
	static BOOL CASH_MUNPA_USE(CUnitPC* pPC, DWORD dwTargetUnique , INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	//거래소 이용
	static BOOL CASH_USER_TRADE(CUnitPC* pPC,DWORD dwSellerUnique, DWORD dwSellerCharunique,INT32 i32TradeIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_USER_TRADE_STORAGE_FIND(CUnitPC* pPC, INT32 i32Price,INT32 i32TradeType, INT32 i32TradeIdx,INT64 i64CashUnique);

	// 밸런스 요청
	static void CASH_BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwMainUnique, DWORD dwSubUnique, CUnitPC* pPC);
	static void WORLD_CASH_BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwMainUnique, DWORD dwSubUnique, CUnitPC* pPC);
	static void ETCCost_BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwMainUnique, DWORD dwSubUnique, CUnitPC* pPC);

	// 취소 요청
	static BOOL CANCEL(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, INT32 i32CostType, DWORD dwAccUnique, DWORD dwCharUnique, DWORD dwFieldUnique, int Price, WCHAR* pMemo, INT64 cashId);

	
	//////////////////////////////////////////////////////
	///						기타						//////
	//////////////////////////////////////////////////////
	void SetCashPurchase(char* param, char* productIndex);
	static void SetSendMsgTypeStr(INT32 i32Type, char eTypeStr[CASH_TYPE_TEXT_LENGTH]);

	stCashProcessInfo* FindCashProcess(DWORD dwID);
	void EraseCashProcess(DWORD dwID);
	INT32 AddCashProcess(INT64* i64Value, INT32 i32Table);
	stCashTrade* GetCashTrade(ENUM_CASH_TRADE_TYPE eCashType);
	void ReturnCashTrade(stCashTrade* pInfo);
	stCashTrade* FindCashTrade(INT32 i32CashUnqiue);
};

```

</details>


#### 3. CSV파일 컬럼명 읽기 작업
<details>
<summary>기존 코드</summary>

```ruby
bool LoadDataFile()
	{
		Clear();

		int i = 0;
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32Index));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32Floor)); 
		i++; // 클라에서 월드 찾기 위한 컬럼 0 서버, 1 월드
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32MapIndex));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32BossNpcIndex));
		i++;
		i++;
		i++;
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterCostType));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterCostValue));
		i++;
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32OpenHour));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32OpenMinute));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32CloseHour));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32CloseMinute));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnPositionX));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnPositionY));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnHour));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnMinute));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnDays));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32LimitMinute));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterLimitLevelMin));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterLimitLevelMax));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterLimitBossIndex));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32MaxPlayerCount));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ExitTime));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32WarpX));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32WarpY));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32HpWeight));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ReturnMapIndex));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ReturnXPos));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ReturnYPos));

		SetKeyField(0);

		char szFile[256];
		g_Global.GetRootPath();
		sprintf(szFile, "%s\\_DATA\\1003B2M_BossRaidInfo.csv", g_Global.m_szRootPath);
		if (LoadCSVFile(szFile) == false)
		{
			printf("Can't load data file (%s).\n", szFile);
			return false;
		}
		Close();
		return true;
	}
```

</details>


<details>
<summary>변경 코드</summary>

```ruby
	bool LoadDataFile()
	{
		Clear();
		char szFile[256];
		g_Global.GetRootPath();
		sprintf(szFile, "%s\\_DATA\\1003B2M_BossRaidInfo.csv", g_Global.m_szRootPath);
		if (LoadHeader(szFile) == false)
		{
			printf("Can't load data file (%s).\n", szFile);
			return false;
		}


		AddField(GetColumnIndex("Index"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32Index));
		AddField(GetColumnIndex("Stairs"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32Floor));
	
		AddField(GetColumnIndex("MapIndex"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32MapIndex));
		AddField(GetColumnIndex("BossIndex"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32BossNpcIndex));

		AddField(GetColumnIndex("EntranceCostType"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterCostType));
		AddField(GetColumnIndex("EntranceCost"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterCostValue));

		AddField(GetColumnIndex("OpenTime"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32OpenHour));
		AddField(GetColumnIndex("OpenMinute"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32OpenMinute));
		AddField(GetColumnIndex("CloseTime"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32CloseHour));
		AddField(GetColumnIndex("CloseMinute"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32CloseMinute));
		AddField(GetColumnIndex("SpawnX"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnPositionX));
		AddField(GetColumnIndex("SpawnY"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnPositionY));
		AddField(GetColumnIndex("SpawnTime"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnHour));
		AddField(GetColumnIndex("SpawnMinute"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnMinute));
		AddField(GetColumnIndex("SpawnDays"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnDays));
		AddField(GetColumnIndex("LimitMinute"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32LimitMinute));
		AddField(GetColumnIndex("LimitLevel"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterLimitLevelMin));
		AddField(GetColumnIndex("LimitLevelMax"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterLimitLevelMax));
		AddField(GetColumnIndex("LimitIndex"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterLimitBossIndex));
		AddField(GetColumnIndex("MaxCount"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32MaxPlayerCount));
		AddField(GetColumnIndex("ExitTime(s)"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ExitTime));
		AddField(GetColumnIndex("WarpX"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32WarpX));
		AddField(GetColumnIndex("WarpY"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32WarpY));
		AddField(GetColumnIndex("HPWeight"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32HpWeight));
		AddField(GetColumnIndex("ExitMapIndex"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ReturnMapIndex));
		AddField(GetColumnIndex("ExitWarpX"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ReturnXPos));
		AddField(GetColumnIndex("ExitWarpY"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ReturnYPos));

		SetKeyField(0);


		LoadCSVFile(szFile);

		Close();
		return true;
	}

```

</details>



