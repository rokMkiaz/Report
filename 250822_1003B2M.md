### 남일우
#### 1. 생활 컨텐츠 이식 작업
<details>
<summary>생활</summary>
  
  ```ruby
struct LifeResultData
{
	INT32 _i32ResultItemIndex;
	INT32 _i32Percent;
	INT32 _i32Count;
};


enum LIFE_OBJECT_TYPE
{
	LIFE_DATA_OBJECT_TILE,
	LIFE_DATA_OBJECT_NPC,
	LIFE_DATA_OBJECT_MAX,
};

class CLifeData
{
public:
	CLifeData() {}
	CLifeData(INT32 i32EquipItemIndex) { _i32EquipIndex = i32EquipItemIndex; }

	~CLifeData() {}

	void PushData(INT32 i32ResultItem, INT32 i32Precent, INT32 i32Count);
	INT32 GetResultItem();
	vector<LifeResultData>& GetData() {	return _vResultData;  };

private:
	INT32 _i32EquipIndex;
	vector<LifeResultData> _vResultData;
};

class CLifeManager
{
public:
	CLifeManager() {}
	~CLifeManager() {}

	void Release();
	void LoadData();
	void ReloadLifeInfo();
	void ReloadLifeSujibInfo();
	void ReloadLifeExp();
	void ReloadLifeMonthlyFee();
	void ReloadLifeExpSetting();

	INT32 GetRewardItemIndex(INT32 i32EquipItemIndex);
	INT32 GetRewardItemCountFromIndex(INT32 i32EquipItemIndex,INT32 i32ItemIndex); // 23.10.10 진공 csv 갯수추가
	BOOL LifeAction(INT32 i32Type,CUnitPC* pPC, INT32 i32Direction, BOOL bRelay = FALSE);

	void AddLifeExp(CUnitPC* pPC, INT32 i32LifeType);
	void AddFameExp(CUnitPC* pPC);
	void UpdateLevelByExp(CUnitPC* pPC, INT32 i32LifeType);
	_CSV_1003BM_LIFE_SUJIB_DATA* FindLifeSujibData(INT32 i32LifeType, INT32 i32Level);
	INT32 GetLevelUpExp(INT32 i32LifeType, INT32 i32CurLevel);
	_CSV_1003BM_LIFE_MONTHLY_FEE_DATA* FindLifeMonthlyFeeData(INT32 i32CashStoreIndex);

	void GmSetLifeLevel(CUnitPC* pPC, INT32 i32LifeType, INT32 i32Level);	//운영자 명령어
private:
	map<INT32,CLifeData*> _mapLifeData; // 키값은 아이템 인덱스
	_CSV_1003BM_LIFE_SUJIB_DATA _lifeSujibData[LIFE_DATA_TYPE::LIFE_DATA_TYPE_MAX][MAX_LIFE_LEVEL + 1];	// 수집효과 [생활타입][레벨]
	_CSV_1003BM_LIFE_EXP_DATA _lifeExpData[MAX_LIFE_LEVEL + 1];	//경험치 [레벨]
	map<INT32, _CSV_1003BM_LIFE_MONTHLY_FEE_DATA*> _mapLifeMonthlyFeeData;	//월정액 [캐시스토어idx][월정액data]
	vector<_CSV_1003BM_LIFE_EXP_SETTING_DATA*> _vecLifeExpSettingData;	//명성 구간 별 획득 경험치 계산 상수
};

class CLifeList
{
public:
	CLifeList() { Init(); }
	~CLifeList() {}

	void Init();

	void SetLifeInfo(stLifeInfo* stLifeInfo);
	void SendLifeInfo(CUnitPC* pPC);
	void SaveLifeInfo(CUnitPC* pPC);
	void LifeAbilityUpdate(CUnitPC* pPC, BOOL bSend);

	INT32 GetLevel(INT32 i32LifeType);
	void SetLevel(INT32 i32LifeType, INT32 i32Level);
	INT32 GetExp(INT32 i32LifeType);
	void SetExp(INT32 i32LifeType, INT32 i32Exp);
	void AddExp(INT32 i32LifeType, INT32 i32Exp);

	//월정액
	void SetLifeMonthlyFeeInfo(stLifeMonthlyFeeInfo* stLifeMonthlyFeeInfo);
	void SendLifeMonthlyFeeInfo(CUnitPC* pPC);
	void AddLifeMonthlyFee(CUnitPC* pPC, INT32 i32CashStoreIndex);
	void LifeMonthlyFeeAbilityUpdate(CUnitPC* pPC, BOOL bSend);
	void LoopMonthlyFeeEnd(CUnitPC* pPC);

private:
	stLifeInfo _stLifeInfo[LIFE_DATA_TYPE::LIFE_DATA_TYPE_MAX];
	unordered_map<INT32, INT32> _mapLifeMonthlyFeeInfo;
};

  ```
</details>

<details>
<summary>경맥</summary>
  
  ```ruby
class CUnitPC;
struct GyeongMaekPercentData
{
	INT32 _i32Point;
	INT32 _i32CostType;
	INT32 _i32Percent[MAX_GYEONGMAEK_PER_OPEN];
	INT32 _i32ResetType;
	INT32 _i32ResetCost;
};

struct GyeongMaekPartsData
{
	INT32 _i32Option[MAX_RELLIC_PARTS_OPTION];
	INT32 _i32Value[MAX_RELLIC_PARTS_OPTION];
	INT32 _i32RewardSkillIndex[MAX_JOB_TYPE];
	INT32 _i32ConditionType; // 조건타입
	INT32 _i32ConditionValue; // 조건벨류 
};

class CGyeongMaekManager
{
public:
	CGyeongMaekManager();
	~CGyeongMaekManager() {};
	void LoadData();
	void OnGyeongMaekEnchant(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup);
	//
	void ResetGyeongMaekList(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup);
	//
	void OnCSCouponGyeonMaek(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup);
	//
	void PaybackMaterial(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup);
	//
	void GetAbility(INT32 i32Group, INT32 i32SubGroup, INT32 i32Step,INT32* _Add_Ability, INT32* _Increase_Ability, vector<INT32>* pDecreaseAb);
	//
	BOOL CheckOpenAll(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup);
	INT32 GetRewardSkillIndex(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup);
	void CheckRewardSkillAndOpen(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup,INT32 i32Count);
	//
	BOOL CheckData(INT32 i32Group, INT32 i32SubGroup);
	INT32 GetRewardSkillIndex(INT32 i32Group, INT32 i32SubGroup,INT32 i32Job);

	BOOL CheckGyungmaekSkill(INT32 i32SkillIndex,INT32 i32Job);

	INT32 GetMaxTryCount(INT32 i32Group, INT32 i32Tab);
	void GMGyungmaek(CUnitPC* pPC, INT32 i32Group, INT32 i32SubGroup, INT32 i32Step);
private:
	GyeongMaekPercentData _stEnchantData[MAX_GYEONGMAEK_GROUP][MAX_GYEONGMAEK_TAB][MAX_GYEONGMAEK_TRY_PER_PAGE];
	GyeongMaekPartsData _stPartsData[MAX_GYEONGMAEK_GROUP][MAX_GYEONGMAEK_TAB][MAX_GYEONGMAEK_PARTS_PER_PAGE];

	set<INT32> _RewardSkillIndex[MAX_JOB_TYPE];
	BOOL bCSCouponUse;
};

extern CGyeongMaekManager g_GyeongMaekManager;


class CUnitPC;
class CGyeongMaekList
{
public:
	CGyeongMaekList();
	~CGyeongMaekList() {};
	void Init();

	void SendGyeongMaekList(CUnitPC* pPC);

	void OpenParts(INT32 i32Group, INT32 i32Tab, INT32 i32PartsIndex);
	void AddEnchantCount(INT32 i32Group, INT32 i32Tab);
	
	void GetList(INT32* pList);
	void SetList(INT32* pList);
	//
	void ResetList();
	void PaybackMaterial(CUnitPC* pPC, INT32 i32Group, INT32 i32Tab);
	void InitResetValue();
	void SetResetValue(INT32 i32Group, INT32 i32Tab);
	//
	void AbilityUpdate(INT32* _Add_Ability, INT32* _Increase_Ability, vector<INT32>* pDecreaseAb);

	INT32 GetEnchantCount(INT32 i32Group, INT32 i32Tab);
	INT32 GetOpenIndex(INT32 i32Group, INT32 i32Tab);

	BOOL GetInitProcess() { return _bInitProcess; }
	void SetInitProcess(BOOL bInit) { _bInitProcess = bInit; }
	//김태수_천장 시스템 추가(경맥)_230424
	void UpCombineCount(CUnitPC* pPC);
	void LoadCombineCount(INT32* i32CombineCount);
	void SaveCombineCount(CUnitPC* pPC);
	void SendCombineCount(CUnitPC* pPC);
	void UseCombineCount(CUnitPC* pPC, INT32 i32Grade); //횟수 사용 및 차감

	INT32 GetOpenGyeongmaekCount();
private:
	INT32 _i32GyeongMaekInfo[MAX_GYEONGMAEK_GROUP][MAX_GYEONGMAEK_TAB][MAX_GYEONGMAEK_PARTS_PER_PAGE]; // 열려있는지 닫혔는지 정보
	INT32 _i32yTryEnchant[MAX_GYEONGMAEK_GROUP][MAX_GYEONGMAEK_TAB]; // 강화횟수 

	BOOL _bInitProcess;
	//김태수_천장 시스템 추가(경맥)_230424
	INT32 _i32CombineCount[COMBINE_COUNT_RANK::COMBINE_MAX]; //횟수
	INT32 _i32CombineRewardCount[COMBINE_COUNT_RANK::COMBINE_MAX]; //1회 보상 필요 횟수

	INT32 _i32InitGroup;
	INT32 _i32InitTab;
};


  ```
</details>


#### 2. CashManager 정리 작업
조선협객전 2M에서 미사용하는 함수들이 많아 정리하였음. 교차검증을 통해 확인 완료

<details>
<summary>기존 코드</summary>

```ruby

class CCashManager
{
public:
	CCashManager();
	bool m_bCash_Purchase[MAX_CASH_SHOP_COUNT];
	list<stCashProcessInfo> _stCashProcessList;
	INT64 _i64CashProcessID;
	map<INT32, queue<stCashTrade*>> _stCashTradeInfoList;
	map<INT32, stCashTrade*> _mapCashTradeInfo;
	INT32 _i32CashInfoUnique;

	static void ON_DSM_CONSUME(BYTE* pPacket);
	static void ON_DSM_CONSUME_SILVER(BYTE* pPacket);
	static void ON_DSM_CONSUME_ETC(BYTE* pPacket);
	static void ON_DSM_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_DEPOSIT_SILVER(BYTE* pPacket);
	static void ON_DSM_DEPOSIT_ETC(BYTE* pPacket);

	static void ON_DSM_CANCEL(BYTE* pPacket);
	static void ON_DSM_BALANCE(BYTE* pPacket);


	static BOOL CONSUME(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, DWORD dwCashUnique, INT32 i32CostType, CUnitPC* pPC, int Price, DWORD dwMemo, WCHAR* pMemo, INT32 i32Type, INT64 i64Bundleunique, cashandtrade* cashtrade = NULL, WCHAR* wSellerName = NULL, DWORD dwSellerAccUnique = 0, int detail1 = 0, int detail2 = 0, int detail3 = 0);
	static BOOL DEPOSIT(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, DWORD dwCashUnique, INT32 i32CostType , CUnitPC* pPC, int Price, DWORD _iProductIdx, WCHAR* pMemo, INT32 i32Type, INT64 _dwProducUnique, cashandtrade* cashtrade = NULL);
	static BOOL CANCEL(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, INT32 i32CostType, DWORD dwAccUnique, DWORD dwCharUnique, DWORD dwFieldUnique, int Price, WCHAR* pMemo, INT64 cashId);
	static BOOL BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, DWORD dwCashUnique, INT32 i32CostType, CUnitPC* pPC);

	static BOOL CONSUME_NEW(ENUM_CASH_TABLE_TYPE eTableType, INT32 i32TradeType, CUnitPC* pPC,DWORD dwMainUnique, DWORD dwSubUnique,INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);
	static BOOL DEPOSIT_NEW(ENUM_CASH_TABLE_TYPE eTableType, INT32 i32TradeType, CUnitPC* pPC, DWORD dwMainUnique, DWORD dwSubUnique, INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);

	static BOOL DEPOSIT_ETCCost(ENUM_CASH_TABLE_TYPE eTableType, INT32 i32CostType, INT32 i32TradeType, CUnitPC* pPC, DWORD dwMainUnique, DWORD dwSubUnique, INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);
	static BOOL CONSUME_ETCCost(ENUM_CASH_TABLE_TYPE eTableType, INT32 i32CostType, INT32 i32TradeType, CUnitPC* pPC, DWORD dwMainUnique, DWORD dwSubUnique, INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);


	//static BOOL CONSUME(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, DWORD dwCashUnique, BOOL bGold, CUnitPC* pPC, int Price, DWORD dwMemo, WCHAR* pMemo, INT32 i32Type, INT64 i64Bundleunique, cashandtrade* cashtrade = NULL, WCHAR* wSellerName = NULL, DWORD dwSellerAccUnique = 0, int detail1 = 0, int detail2 = 0 ,int detail3 = 0);
	//static BOOL DEPOSIT(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, DWORD dwCashUnique,BOOL bGold, CUnitPC* pPC, int Price, DWORD _iProductIdx, WCHAR* pMemo, INT32 i32Type, INT64 _dwProducUnique, cashandtrade* cashtrade = NULL);
	//static BOOL CONSUME(BOOL bGold ,CUnitPC* pPC, int Price, DWORD dwMemo, WCHAR* pMemo, BYTE _Type, INT64 i64Bundleunique, cashandtrade* cashtrade = NULL, WCHAR * wSellerName = NULL, DWORD dwSellerAccUnique = 0 );
	//static BOOL DEPOSIT(BOOL bGold, CUnitPC* pPC, int Price, DWORD _iProductIdx,WCHAR* pMemo, BYTE _Type, INT64 _dwProducUnique, cashandtrade* cashtrade = NULL);
	//static BOOL CANCEL(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, BOOL bGold, DWORD dwAccUnique, DWORD dwCharUnique, DWORD dwFieldUnique, int Price, WCHAR* pMemo, INT64 cashId);
	//static BOOL BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, BOOL bGold, CUnitPC* pPC);

	static BOOL NOT_PC_CONSUME(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, BOOL bGold, DWORD dwAccunique,DWORD dwCharunique, int Price, DWORD dwMemo, WCHAR* pMemo, INT32 i32Type, INT64 i64Bundleunique, cashandtrade* cashtrade = NULL, WCHAR* wSellerName = NULL, DWORD dwSellerAccUnique = 0);
	static BOOL NOT_PC_DEPOSIT(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, BOOL bGold, DWORD dwAccunique, DWORD dwCharunique, int Price, DWORD _iProductIdx, WCHAR* pMemo, INT32 i32Type, INT64 _dwProducUnique, cashandtrade* cashtrade = NULL);
	void SetCashPurchase(char* param, char* productIndex);
	//static void SetSendMsgTypeStr(INT32 i32Type, DCP_REQUEST_CASH* pSendmsg);
	static void SetSendMsgTypeStr(INT32 i32Type, char eTypeStr[CASH_TYPE_TEXT_LENGTH]);

	//거래 진행 차감할곳 , 증감할곳 
	static BOOL CASH_TRADE(ENUM_CASH_TABLE_TYPE eType, ENUM_CASH_TABLE_TYPE eTargetType, DWORD dwMainunique, DWORD dwSubunique, DWORD dwTargetMainUnique,DWORD dwTargetSubUnique,
		INT32 i32Price, INT32 i32TradeType, INT32 i32CashUnique,INT32 i32Detail1, INT32 i32Detail2, INT32 i32TargetDetail1, INT32 i32TargetDetail2);
	//유저 금화 아이템 구매(상점 금화 아이템 구매, 
	static BOOL CASH_USER_BUY(CUnitPC* pPC, INT32 i32ProductID ,INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique, INT32 i32BundleUnique);
	//유저 금화 제외한 기타재화로 아이템 구매
	static BOOL ETCCost_USER_BUY(CUnitPC* pPC, INT32 i32ProductID, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique, INT32 i32BundleUnique,INT32 i32CostType);
	//유저 문파 컨텐츠 이용 (기여)
	static BOOL CASH_USER_MUNPA_USE(CUnitPC* pPC, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	//문파 컨텐츠 이용 (문파 버프 구매 등)
	static BOOL CASH_MUNPA_USE(CUnitPC* pPC, DWORD dwTargetUnique , INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	//거래소 이용
	static BOOL CASH_USER_TRADE(CUnitPC* pPC,DWORD dwSellerUnique, DWORD dwSellerCharunique,INT32 i32TradeIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_USER_TRADE_STORAGE_FIND(CUnitPC* pPC, INT32 i32Price,INT32 i32TradeType, INT32 i32TradeIdx,INT64 i64CashUnique);
	//역참 이용
	static BOOL CASH_STATION_DAY(CUnitPC* pPC,INT32 i32StationIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_CALCULATE_GNI(INT32 i32StationIdx, INT32 i32Value, INT32 i32GinTax, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_CALCULATE_GNI_RETURN(INT32 i32StationIdx, INT32 i32Value, INT32 i32GinTax, DWORD dwReturnMunpaUnique, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_CALCULATE(INT32 i32StationIdx, INT32 i32castleIdx, INT32 i32GinTax,INT32 i32castleTax, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_CALCULATE_RETURN(INT32 i32StationIdx, INT32 i32castleIdx, INT32 i32GinTax, INT32 i32castleTax, DWORD dwReturnMunpaUnique ,INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_USE(CUnitPC* pPC, INT32 i32StationIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_BID_SUCCESS(DWORD dwMunpaUnique, INT32 i32StationIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STATION_BID_FAIL(DWORD dwMunpaUnique, INT32 i32StationIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_MAIL_INPUT(CUnitPC* pPC, DWORD dwMailUnique, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STORAGE_INPUT(CUnitPC* pPC, DWORD dwStorgeIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL ETCCost_MAIL_INPUT(CUnitPC* pPC, DWORD dwMailUnique, INT32 i32CostType, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);

	static BOOL CASH_STATION_OBLATION(CUnitPC* pPC, INT32 i32StationIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);

	// 다이아 가져오기
	static void CASH_BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwMainUnique, DWORD dwSubUnique, CUnitPC* pPC);
	static void WORLD_CASH_BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwMainUnique, DWORD dwSubUnique, CUnitPC* pPC);
	// 기타 재화들 가져오기
	static void ETCCost_BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwMainUnique, DWORD dwSubUnique, CUnitPC* pPC);

	//취소 처리
	static void CASH_ALL_CANCEL(BYTE* pPacket);

	static void ON_DSM_CASH_TRADE(BYTE* pPacket);
	static void ON_DSM_CASH_TRADE_GNI(BYTE* pPacket);
	static void ON_DSM_CASH_TRADE_GNI_RETURN(BYTE* pPacket);
	static void ON_DSM_CASH_TRADE_STORAGE(BYTE* pPacket);
	static void ON_DSM_CASH_CALCULATE(BYTE* pPacket);
	static void ON_DSM_CASH_CALCULATE_RETURN(BYTE* pPacket);
	static void ON_DSM_CASH_ALL_CANCEL(BYTE* pPacket);
	static void ON_DSM_CASH_BALANCE(BYTE* pPacket);

	static void ON_DSM_CONSUME_NEW(BYTE* pPacket);
	static void ON_DSM_DEPOSIT_NEW(BYTE* pPacket);

	static void ON_DSM_ETCCost_TRADE(BYTE* pPacket);
	static void ON_DSM_ETCCost_BALANCE(BYTE* pPacket);
	static void ON_DSM_CONSUME_ETCCost(BYTE* pPacket);
	static void ON_DSM_DEPOSIT_ETCCost(BYTE* pPacket);

	//유저 캐쉬
	static void ON_DSM_USER_CONSUME(BYTE* pPacket);
	static void ON_DSM_USER_CONSUME_SILVER(BYTE* pPacket);
	static void ON_DSM_USER_CONSUME_ETC(BYTE* pPacket);
	static void ON_DSM_USER_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_USER_DEPOSIT_SILVER(BYTE* pPacket);
	static void ON_DSM_USER_DEPOSIT_ETC(BYTE* pPacket);
	static void ON_DSM_USER_CANCEL(BYTE* pPacket);
	static void ON_DSM_USER_BALANCE(BYTE* pPacket);
	
	//문파 캐쉬
	static void ON_DSM_MUNPA_CONSUME(BYTE* pPacket);
	static void ON_DSM_MUNPA_CONSUME_SILVER(BYTE* pPacket);
	static void ON_DSM_MUNPA_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_MUNPA_DEPOSIT_SILVER(BYTE* pPacket);
	static void ON_DSM_MUNPA_CANCEL(BYTE* pPacket);
	static void ON_DSM_MUNPA_BALANCE(BYTE* pPacket);
	
	//성 캐쉬
	static void ON_DSM_CASTLE_CONSUME(BYTE* pPacket);
	static void ON_DSM_CASTLE_CONSUME_SILVER(BYTE* pPacket);
	static void ON_DSM_CASTLE_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_CASTLE_DEPOSIT_SILVER(BYTE* pPacket);
	static void ON_DSM_CASTLE_CANCEL(BYTE* pPacket);
	static void ON_DSM_CASTLE_BALANCE(BYTE* pPacket);
	
	//GNI 세금 -> 빼는 것은 없고 넣는 것만 있다.
	static void ON_DSM_GNI_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_GNI_DEPOSIT_SILVER(BYTE* pPacket);
	static void ON_DSM_GNI_CANCEL(BYTE* pPacket);
	static void ON_DSM_GNI_BALANCE(BYTE* pPacket);
	
	//성 일일 정산 세금
	static void ON_DSM_CASTLE_DAY_CONSUME(BYTE* pPacket);
	static void ON_DSM_CASTLE_DAY_CONSUME_SILVER(BYTE* pPacket);
	static void ON_DSM_CASTLE_DAY_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_CASTLE_DAY_DEPOSIT_SILVER(BYTE* pPacket);
	static void ON_DSM_CASTLE_DAY_CANCEL(BYTE* pPacket);
	static void ON_DSM_CASTLE_DAY_BALANCE(BYTE* pPacket);
	
	//거래소 세금
	static void ON_DSM_TRADE_CONSUME(BYTE* pPacket);
	static void ON_DSM_TRADE_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_TRADE_CANCEL(BYTE* pPacket);
	
	//메일 잔금
	static void ON_DSM_MAIL_CONSUME(BYTE* pPacket);
	static void ON_DSM_MAIL_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_MAIL_CANCEL(BYTE* pPacket);
	
	//역참 잔금
	static void ON_DSM_STATION_CONSUME(BYTE* pPacket);
	static void ON_DSM_STATION_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_STATION_CANCEL(BYTE* pPacket);
	static void ON_DSM_STATION_BALANCE(BYTE* pPacket);
	
	//역참 일일 정산 세금
	static void ON_DSM_STATION_DAY_CONSUME(BYTE* pPacket);
	static void ON_DSM_STATION_DAY_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_STATION_DAY_CANCEL(BYTE* pPacket);
	static void ON_DSM_STATION_DAY_BALANCE(BYTE* pPacket);
	
	//역참 경매
	static void ON_DSM_STATION_BID_CONSUME(BYTE* pPacket);
	static void ON_DSM_STATION_BID_DEPOSIT(BYTE* pPacket);
	static void ON_DSM_STATION_BID_CANCEL(BYTE* pPacket);
	static void ON_DSM_STATION_BID_BALANCE(BYTE* pPacket);

	// 공성 던전 분배
	static void ON_DSM_CASTLE_DISTRIBUTE(BYTE* pPacket);

	stCashProcessInfo* FindCashProcess(DWORD dwID);
	void EraseCashProcess(DWORD dwID);
	INT32 AddCashProcess(INT64* i64Value, INT32 i32Table);
	stCashTrade* GetCashTrade(ENUM_CASH_TRADE_TYPE eCashType);
	void ReturnCashTrade(stCashTrade* pInfo);
	stCashTrade* FindCashTrade(INT32 i32CashUnqiue);
};
```

</details>


<details>
<summary>변경 후</summary>

```ruby
class CCashManager
{
public:
	CCashManager();
	bool m_bCash_Purchase[MAX_CASH_SHOP_COUNT];
	list<stCashProcessInfo> _stCashProcessList;
	INT64 _i64CashProcessID;
	map<INT32, queue<stCashTrade*>> _stCashTradeInfoList;
	map<INT32, stCashTrade*> _mapCashTradeInfo;
	INT32 _i32CashInfoUnique;

	//////////////////////////////////////////////////////
	///				CashDB - > Game					//////
	//////////////////////////////////////////////////////
	static void ON_DSM_CONSUME_NEW(BYTE* pPacket);
	static void ON_DSM_DEPOSIT_NEW(BYTE* pPacket);

	static void ON_DSM_CASH_TRADE(BYTE* pPacket);
	static void ON_DSM_CASH_TRADE_GNI(BYTE* pPacket);
	static void ON_DSM_CASH_TRADE_GNI_RETURN(BYTE* pPacket);
	static void ON_DSM_CASH_TRADE_STORAGE(BYTE* pPacket);

	static void ON_DSM_CASH_CALCULATE(BYTE* pPacket);
	static void ON_DSM_CASH_CALCULATE_RETURN(BYTE* pPacket);

	static void ON_DSM_ETCCost_TRADE(BYTE* pPacket);
	static void ON_DSM_ETCCost_BALANCE(BYTE* pPacket);
	static void ON_DSM_CONSUME_ETCCost(BYTE* pPacket);
	static void ON_DSM_DEPOSIT_ETCCost(BYTE* pPacket);
	//밸런스 반영
	static void ON_DSM_CASH_BALANCE(BYTE* pPacket);
	//취소 처리
	static void ON_DSM_CANCEL(BYTE* pPacket);
	static void CASH_ALL_CANCEL(BYTE* pPacket);
	static void ON_DSM_USER_CANCEL(BYTE* pPacket);
	static void ON_DSM_MUNPA_CANCEL(BYTE* pPacket);

	//////////////////////////////////////////////////////
	///				Game - > CashDB					//////
	//////////////////////////////////////////////////////
	static BOOL CASH_USER_CONSUME_ALLTYPE(ENUM_CASH_TABLE_TYPE eTableType, CASH_TYPE i32TradeType, CUnitPC* pPC,DWORD dwMainUnique, DWORD dwSubUnique,INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);
	static BOOL CASH_USER_DEPOSIT_ALLTYPE(ENUM_CASH_TABLE_TYPE eTableType, CASH_TYPE i32TradeType, CUnitPC* pPC, DWORD dwMainUnique, DWORD dwSubUnique, INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);
	static BOOL DEPOSIT_ETCCost(ENUM_CASH_TABLE_TYPE eTableType, INT32 i32CostType, INT32 i32TradeType, CUnitPC* pPC, DWORD dwMainUnique, DWORD dwSubUnique, INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);
	static BOOL CONSUME_ETCCost(ENUM_CASH_TABLE_TYPE eTableType, INT32 i32CostType, INT32 i32TradeType, CUnitPC* pPC, DWORD dwMainUnique, DWORD dwSubUnique, INT32 i32Price, INT64 i64CashUnique, int detail1 = 0, int detail2 = 0);

	static BOOL CASH_MAIL_INPUT(CUnitPC* pPC, DWORD dwMailUnique, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_STORAGE_INPUT(CUnitPC* pPC, DWORD dwStorgeIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL ETCCost_MAIL_INPUT(CUnitPC* pPC, DWORD dwMailUnique, INT32 i32CostType, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);

	//컨텐츠 전용
	//유저 금화 아이템 구매(상점 금화 아이템 구매, 
	static BOOL CASH_USER_BUY(CUnitPC* pPC, INT32 i32ProductID ,INT32 i32Price, CASH_TYPE eTradeType, INT64 i64CashUnique, INT32 i32BundleUnique);
	//유저 금화 제외한 기타재화로 아이템 구매
	static BOOL ETCCost_USER_BUY(CUnitPC* pPC, INT32 i32ProductID, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique, INT32 i32BundleUnique,INT32 i32CostType);
	//유저 문파 컨텐츠 이용 (기여)
	static BOOL CASH_USER_MUNPA_USE(CUnitPC* pPC, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	//문파 컨텐츠 이용 (문파 버프 구매 등)
	static BOOL CASH_MUNPA_USE(CUnitPC* pPC, DWORD dwTargetUnique , INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	//거래소 이용
	static BOOL CASH_USER_TRADE(CUnitPC* pPC,DWORD dwSellerUnique, DWORD dwSellerCharunique,INT32 i32TradeIdx, INT32 i32Price, INT32 i32TradeType, INT64 i64CashUnique);
	static BOOL CASH_USER_TRADE_STORAGE_FIND(CUnitPC* pPC, INT32 i32Price,INT32 i32TradeType, INT32 i32TradeIdx,INT64 i64CashUnique);

	// 밸런스 요청
	static void CASH_BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwMainUnique, DWORD dwSubUnique, CUnitPC* pPC);
	static void WORLD_CASH_BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwMainUnique, DWORD dwSubUnique, CUnitPC* pPC);
	static void ETCCost_BALANCE(ENUM_CASH_TABLE_TYPE eType, DWORD dwMainUnique, DWORD dwSubUnique, CUnitPC* pPC);

	// 취소 요청
	static BOOL CANCEL(ENUM_CASH_TABLE_TYPE eType, DWORD dwUnique, INT32 i32CostType, DWORD dwAccUnique, DWORD dwCharUnique, DWORD dwFieldUnique, int Price, WCHAR* pMemo, INT64 cashId);

	
	//////////////////////////////////////////////////////
	///						기타						//////
	//////////////////////////////////////////////////////
	void SetCashPurchase(char* param, char* productIndex);
	static void SetSendMsgTypeStr(INT32 i32Type, char eTypeStr[CASH_TYPE_TEXT_LENGTH]);

	stCashProcessInfo* FindCashProcess(DWORD dwID);
	void EraseCashProcess(DWORD dwID);
	INT32 AddCashProcess(INT64* i64Value, INT32 i32Table);
	stCashTrade* GetCashTrade(ENUM_CASH_TRADE_TYPE eCashType);
	void ReturnCashTrade(stCashTrade* pInfo);
	stCashTrade* FindCashTrade(INT32 i32CashUnqiue);
};

```

</details>


#### 3. CSV파일 컬럼명 읽기 작업
<details>
<summary>기존 코드</summary>

```ruby
bool LoadDataFile()
	{
		Clear();

		int i = 0;
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32Index));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32Floor)); 
		i++; // 클라에서 월드 찾기 위한 컬럼 0 서버, 1 월드
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32MapIndex));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32BossNpcIndex));
		i++;
		i++;
		i++;
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterCostType));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterCostValue));
		i++;
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32OpenHour));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32OpenMinute));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32CloseHour));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32CloseMinute));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnPositionX));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnPositionY));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnHour));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnMinute));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnDays));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32LimitMinute));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterLimitLevelMin));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterLimitLevelMax));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterLimitBossIndex));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32MaxPlayerCount));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ExitTime));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32WarpX));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32WarpY));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32HpWeight));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ReturnMapIndex));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ReturnXPos));
		AddField(i++, CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ReturnYPos));

		SetKeyField(0);

		char szFile[256];
		g_Global.GetRootPath();
		sprintf(szFile, "%s\\_DATA\\1003B2M_BossRaidInfo.csv", g_Global.m_szRootPath);
		if (LoadCSVFile(szFile) == false)
		{
			printf("Can't load data file (%s).\n", szFile);
			return false;
		}
		Close();
		return true;
	}
```

</details>


<details>
<summary>변경 코드</summary>

```ruby
	bool LoadDataFile()
	{
		Clear();
		char szFile[256];
		g_Global.GetRootPath();
		sprintf(szFile, "%s\\_DATA\\1003B2M_BossRaidInfo.csv", g_Global.m_szRootPath);
		if (LoadHeader(szFile) == false)
		{
			printf("Can't load data file (%s).\n", szFile);
			return false;
		}


		AddField(GetColumnIndex("Index"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32Index));
		AddField(GetColumnIndex("Stairs"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32Floor));
	
		AddField(GetColumnIndex("MapIndex"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32MapIndex));
		AddField(GetColumnIndex("BossIndex"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32BossNpcIndex));

		AddField(GetColumnIndex("EntranceCostType"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterCostType));
		AddField(GetColumnIndex("EntranceCost"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterCostValue));

		AddField(GetColumnIndex("OpenTime"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32OpenHour));
		AddField(GetColumnIndex("OpenMinute"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32OpenMinute));
		AddField(GetColumnIndex("CloseTime"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32CloseHour));
		AddField(GetColumnIndex("CloseMinute"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32CloseMinute));
		AddField(GetColumnIndex("SpawnX"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnPositionX));
		AddField(GetColumnIndex("SpawnY"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnPositionY));
		AddField(GetColumnIndex("SpawnTime"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnHour));
		AddField(GetColumnIndex("SpawnMinute"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnMinute));
		AddField(GetColumnIndex("SpawnDays"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32SpawnDays));
		AddField(GetColumnIndex("LimitMinute"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32LimitMinute));
		AddField(GetColumnIndex("LimitLevel"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterLimitLevelMin));
		AddField(GetColumnIndex("LimitLevelMax"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterLimitLevelMax));
		AddField(GetColumnIndex("LimitIndex"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32EnterLimitBossIndex));
		AddField(GetColumnIndex("MaxCount"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32MaxPlayerCount));
		AddField(GetColumnIndex("ExitTime(s)"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ExitTime));
		AddField(GetColumnIndex("WarpX"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32WarpX));
		AddField(GetColumnIndex("WarpY"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32WarpY));
		AddField(GetColumnIndex("HPWeight"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32HpWeight));
		AddField(GetColumnIndex("ExitMapIndex"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ReturnMapIndex));
		AddField(GetColumnIndex("ExitWarpX"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ReturnXPos));
		AddField(GetColumnIndex("ExitWarpY"), CSV_DATATYPE_INT, offsetof(_CSV_1003B2M_BOSS_RAID_INFO_DATA, _i32ReturnYPos));

		SetKeyField(0);


		LoadCSVFile(szFile);

		Close();
		return true;
	}

```

</details>

### 조현진 선임

# 천상비2M 이벤트 구조 개선 **Cursor AI**를 활용하여 기존 이벤트 구조의 문제점을 파악하고 구조 개선 - **기존 이벤트 구조의 문제** - **1. 새로운 이벤트 추가 시 수정해야 할 곳들 (최소 10개 파일을 수정)**
cpp
        // 새로운 "시즌패스 이벤트" 추가 시:
        
        // 1. EventManager.h에 멤버 변수 추가
        CSeasonPassEvent _seasonPassEvent;  // 새로 추가
        
        // 2. EventManager.cpp의 ReloadData() 함수에 case 추가
        case ENUM_CSV_1003B2M_SeasonPassEventInfo:
        {
            g_CSVFile_1003B2M_SeasonPassEventInfo.LoadDataFile();
            LoadSeasonPassRewardData();  // 새로 추가
        }
        break;
        
        // 3. LoadSeasonPassRewardData() 함수 추가
        void CEventManager::LoadSeasonPassRewardData()
        {
            // 새로운 로드 로직 구현
        }
        
        // 4. LoadEventInfo() 함수에 switch case 추가
        switch (pEventData->i32Type)
        {
            // ... 기존 case들 ...
            case ENUM_EVENT_TYPE::EVENT_SEASON_PASS:
                _seasonPassEvent.SetEventData(stEventInfo);  // 새로 추가
                break;
        }
        
        // 5. SP_EVENT_LIST 패킷에 필드 추가
        struct SP_EVENT_LIST
        {
            // ... 기존 필드들 ...
            EventInfo _SeasonPassInfo;  // 새로 추가
            EventInfo2 _SeasonPassRewardItemList[MAX_SEASON_PASS_EVENT];
        };
        
        // 6. 패킷 처리 함수 추가
        void CEventManager::ProcessSeasonPassRequest(CUnitPC* pPC, BYTE* pPacket)
        {
            // 새로운 패킷 처리 로직
        }
        
        // 7. CSV 파일 헤더 추가
        #include "CSVFile_1003B2M_SeasonPassEventInfo.h"
        
        // 8. CSV 파일 생성
        // CSVFile_1003B2M_SeasonPassEventInfo.h
        // CSVFile_1003B2M_SeasonPassEventInfo.cpp
        
        // 9. CSV 열거형 추가
        // TIDefine.h에 ENUM_CSV_1003B2M_SeasonPassEventInfo 추가
        
        // 10. 서버툴에 CSV 등록
        // ServerCsvReloadDlg.cpp에 새 CSV 추가
- **2-1. 클래스 파일 하나에 모든 이벤트가 다 모여 있음** **하나의 파일 안에서 모든 이벤트 내용을 처리하려고 하니 이벤트가 추가 될 때마다 줄이 계속 늘어난다.** **이로 인해 이벤트가 늘어날수록 코드 추적에 시간이 소모된다.** **예시: EventList.h (유저 이벤트 정보 선언)**
cpp
        // 각 이벤트별 유저들이 가지고 있어야 할 정보 List
        
        class CAttendanceSpecialEventList : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
        class CCollectionEventList : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
        class CDrawEventList : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
        class CReturnEvent : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
        class CDayPlayEvent : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
        class CMissionEventList : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
        class CAttendanceEventList : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
        class CBingoEventList : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
        class CStackChargingEventList : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
        class CLevelUpEventList : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
        class CPlayYutEventList : public CEventRewardProgress { // ... 멤버 함수, 변수 선언 }
        
        class CEventRewardProgress
        {
        public:
        	CEventRewardProgress();
        	~CEventRewardProgress() {};
        
        public:
        	INT32 GetEventType() { return _i32EventType; }
        	virtual UINT32 GetEventUnique() { return _ui32EventUnique; }
        	virtual void Init();
        	void EventSetting(UINT32 ui32EventUnique, INT32 i32EventType);
        	BOOL GetSetting() { return _bSetting; }
        	void Setting() { _bSetting = TRUE; }
        private:
        	BOOL _bSetting;
        	UINT32 _ui32EventUnique;
        	INT32 _i32EventType;
        };
        
        class EventList
        {
        public : 
        	EventList();
        	~EventList() {};
        	
        	UINT32 GetDayPlayTime();
        	
        	void SaveEventProgress(CUnitPC* pPC);
        	void RequestUserList(CUnitPC* pPC, INT32 i32EventUnique = 0);
        
        	void InitDayPlayEvent();
        	void InitDay(CUnitPC* pPC, BOOL bWeek);
        public :
        	void init();
        	
        	void ProcessEventDayInit(CUnitPC* pPC); 
        	void ProcessAttendance(CUnitPC* pPC);		
        	void ProcessNewAttendance(CUnitPC* pPC);	
        	void ProcessReturnAttendance(CUnitPC* pPC);	
        	void ProcessEventAttendance(CUnitPC* pPC);	
        	void ProcessEventAttendanceFree(CUnitPC* pPC);	
        
        	BOOL m_bEventRequest;
        
        	INT32 _i32Ready;
        
        	//신규7일이벤트 
        	CAttendanceSpecialEventList _firstweekEvent;
        
        	//복귀 유저 이벤트 
        	CAttendanceSpecialEventList _ReturnUserEvent;
        
        	//특별 출석 이벤트
        	CAttendanceSpecialEventList _AttendSpecialEvnet;
        
        	//출석이벤트
        	CAttendanceEventList _attendEvent;
        
        	// 누적접속 이벤트 
        	CDayPlayEvent _DayplayEvent;
        
        	//수집이벤트
        	CCollectionEventList _CollectionEvent;
        
        	//미션이벤트
        	CMissionEventList _MissionEventList;
        
        	//빙고이벤트
        	CBingoEventList _BingoEventList;
        
        	//뽑기 이벤트
        	CDrawEventList _DrawEventList;
        
        	//충전 이벤트
        	CStackChargingEventList _StackChargingEventList;
        
        	//레벨업 이벤트
        	CLevelUpEventList _LevelUpEvent;
        
        	// 윷놀이 이벤트
        	CPlayYutEventList _PlayYutEventList;
        
        	//7일 출석 이벤트
        	CAttendanceSpecialEventList _AttendSpecialEvnetFree;
        };
--- **예시: EventList.cpp (유저 이벤트 정보 정의)**
cpp
        // EventList, 각 이벤트 List 멤버 변수, 함수 정의
        // 조협2M 기준 약 3100줄
- **2-2. 새로운 이벤트 추가 및 기존 이벤트 수정 시 유지보수가 힘듦** **Save, Load를 할 때 하나의 함수에서 모든 이벤트가 처리되고 있어서 추적이 힘듦. 2-1과 마찬가지로 이벤트가 늘어날수록 코드 추적에 시간 소모** **Event Save**
cpp
        // **Game -> Account로 Save 패킷 전송**
        // **실제로 사용하는 이벤트 개수가 10개 미만으로 적게 확인 되는데 Save 함수 하나에 400줄 가량의 코드가 몰려 있다. (주석 포함)**
        void EventList::SaveEventProgress(CUnitPC* pPC)
        {	
        	if (pPC == NULL)
        		return;
        
        	for (auto mapIter = g_EventManager._mapEventData.begin(); mapIter != g_EventManager._mapEventData.end(); ++mapIter)
        	{
        		if (mapIter->second->GetEventType() == ENUM_EVENT_TYPE::EVENT_ATTENDANCE) { // ... Save 패킷 구성 로직 }
        		else if (mapIter->second->GetEventType() == ENUM_EVENT_TYPE::EVENT_DAY_PLAY) { // ... Save 패킷 구성 로직 }
        		else if (mapIter->second->GetEventType() == ENUM_EVENT_TYPE::EVENT_MISSION) { // ... Save 패킷 구성 로직 }
        		else if (mapIter->second->GetEventType() == ENUM_EVENT_TYPE::EVENT_BINGO) { // ... Save 패킷 구성 로직 }
        		else if (mapIter->second->GetEventType() == ENUM_EVENT_TYPE::EVENT_COLLECT) { // ... Save 패킷 구성 로직 }
        		else if (mapIter->second->GetEventType() == ENUM_EVENT_TYPE::EVENT_DRAW) { // ... Save 패킷 구성 로직 }
        		else if (mapIter->second->GetEventType() == ENUM_EVENT_TYPE::EVENT_STACK_CHARGING) { // ... Save 패킷 구성 로직 }
        		else if (mapIter->second->GetEventType() == ENUM_EVENT_TYPE::EVENT_PLAY_YUT) { // ... Save 패킷 구성 로직 }
        	}
        }
**Event Load**
cpp
        // **유저 접속 후 Game -> AccountDB 서버에 정보 요청**
        // **AccountDB에서 DB로드 후 Game서버에 리턴 하는 함수 (약 1000줄)**
        void CGameManager::ON_DCM_LOAD_EVENT_REWARD_PROGRESS(int iClient, WORD wExtraHeader, BYTE* pPacket)
        {
        	// **각 조건 블록에서 프로시저 실행 후 데이터 로드하여 Game서버에 보낼 패킷 구성**
        	if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_DAY_PLAY) {}
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_ATTENDANCE)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_NEWATTENDANCE	|| pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_ATTENDANCE_RETURN)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_SPECIAL_ATTENDANCE)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_MISSION)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_BINGO)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_DRAW)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_COLLECT)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_STACK_CHARGING)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_LEVELUP_PACKAGE)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_PLAY_YUT)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_SPECIAL_ATTENDANCE_FREE)
        }
**AccountDB → Game 로드한 데이터 PC에 세팅**
cpp
        void CEventManager::ON_LOAD_USERS_EVENT_DATA(BYTE* pPacket)
        {
        	// **각 조건 블록에서 로드한 데이터 PC에 세팅하는 처리 (약 500줄)**
        	if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_ATTENDANCE)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_NEWATTENDANCE)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_ATTENDANCE_RETURN)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_SPECIAL_ATTENDANCE)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_MISSION)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_BINGO)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_DRAW)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_COLLECT)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_STACK_CHARGING)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_LEVELUP_PACKAGE)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_PLAY_YUT)
        	else if (pMsg->i32EventType == ENUM_EVENT_TYPE::EVENT_SPECIAL_ATTENDANCE_FREE)
        }
- **3. 기존 코드의 중복 문제 (예시: LoadEventInfo())**
cpp
        void CEventManager::LoadEventInfo()
        {
            _CSV_1003B2M_EVENT_DATA* pEventData = g_CSVFile_1003B2M_EventInfo.GetFirstRecordData();
            
            while (pEventData)
            {
                EventInfoData stEventInfo;
                // ... 공통 데이터 설정 ...
                
                switch (pEventData->i32Type)
                {
                case ENUM_EVENT_TYPE::EVENT_ATTENDANCE:
                    _attendanceEvent.SetEventData(stEventInfo);
                    break;
                case ENUM_EVENT_TYPE::EVENT_COLLECTION:
                    _CollectEvent.SetEventData(stEventInfo);
                    break;
                case ENUM_EVENT_TYPE::EVENT_MISSION:
                    _MissionEvent.SetEventData(stEventInfo);
                    break;
                case ENUM_EVENT_TYPE::EVENT_BINGO:
                    _BingoEvent.SetEventData(stEventInfo);
                    break;
                case ENUM_EVENT_TYPE::EVENT_DRAW:
                    _DrawEvent.SetEventData(stEventInfo);
                    break;
                case ENUM_EVENT_TYPE::EVENT_STACK_CHARGE:
                    _StackChargeEvent.SetEventData(stEventInfo);
                    break;
                case ENUM_EVENT_TYPE::EVENT_LEVEL_UP:
                    _levelUpEvent.SetEventData(stEventInfo);
                    break;
                case ENUM_EVENT_TYPE::EVENT_PLAY_YUT:
                    _PlayYutEvent.SetEventData(stEventInfo);
                    break;
                // 새로운 이벤트 추가 시마다 case 추가 필요!
                }
                
                pEventData = g_CSVFile_1003B2M_EventInfo.GetNextRecordData();
            }
        }
- **4. 문서 하나에 모든 이벤트를 같이 사용함** **1003bM_EventInfo.csv** - 이벤트 별로 사용하는 열이 있고, 사용하지 않는 열이 있음 ![image.png](attachment:11f4a158-f8fc-44e8-bf62-31843ef48cb9:image.png) **1003bM_EventReward.csv** - 이벤트 별로 사용하는 열이 있고, 사용하지 않는 열이 있음 - 이벤트 별로 사용하는 열의 내용이 모두 다름 (이벤트마다 문서를 새로 만드는게 아니라 이 문서에 필요한 모든 값들을 넣음) - 해당 이벤트 기획 담당자가 아니면 이벤트 추가하기 어려움 ![image.png](attachment:b8de4dc0-67e6-424f-b099-5bda31b383f1:image.png) --- **이벤트 개선된 구조** - **생성 흐름도 (EventV2Manager - 이벤트 데이터 객체 생성, 데이터 로드)**
cpp
    1. EventV2Manager::Initialize()
        ↓
    2. CEventV2Manager::RegisterV2EventDatas()
        ↓
    3. CEventV2Manager::RegisterEvent<EventT>(ENUM_EVENT_TYPE) 이벤트 등록 함수 호출
        ↓
    4. new CAttendanceEventV2Data(eventType) 파생 클래스 생성자 호출
        ↓
    5. CAttendanceEventV2Data 파생 클래스 생성자 시작
        ↓
    6. CAttendanceEventV2Data(ENUM_EVENT_TYPE eventType) : CEventDataV2(eventType) 베이스 클래스 생성자 시작
        ↓
    8. CEventDataV2 베이스 클래스 생성자 완료
        ↓
    10. CAttendanceEventV2Data 파생 클래스 생성자 완료
        ↓
    3 ~ 10 이벤트 개수 만큼 반복 - _mapEventV2Data멤버 변수에 이벤트 클래스 캐싱
        ↓
    11. CEventV2Manager::RegisterV2EventDatas() 함수 완료
        ↓
    12. EventV2Manager::Initialize() - LoadAllEventDataFromCSV() 데이터 로드 함수 호출
        ↓
    13. RegisterV2EventDatas() 함수를 통해 생성된 _mapEventV2Data<ENUM_EVENT_TYPE, CEventDataV2*>에 접근하여 LoadFromCSV() 호출
    void CEventV2Manager::LoadAllEventDataFromCSV()
    {
        for (auto& pair : _mapEventV2Data)
        {
            if (pair.second)
            {
                if (pair.second->LoadFromCSV() == FALSE) {... 실패 메시지 출력}
            }
        }
    }
        ↓
    14. CEventDataV2(베이스 클래스)의 LoadFromCSV()는 순수가상함수라 이벤트별 파생 클래스의 함수를 호출 하게 된다.
    BOOL CAttendanceEventV2Data::LoadFromCSV()
    {
        // 1. 출석 이벤트 기본 정보 로드(베이스 클래스 함수 호출)
        if (CEventDataV2::LoadBasicEventDataFromCSV() == FALSE)
        {
            return FALSE;
        }
    
        // 2. 출석 이벤트 고유 정보 로드
        if (LoadEventSpecificDataFromCSV() == FALSE)
        {
            return FALSE;
        }
    
        SetDataSet(TRUE);
        ActivateEvent();
    
        return TRUE;
    }
        ↓
    15. 등록된 모든 이벤트 데이터 로드 이후 EventV2Manager::Initialize() 종료
- **생성 흐름도 (EventV2List - 이벤트 리스트 객체 생성: 이벤트 별 유저 진행 정보)**
cpp
    1. CEventV2List::CEventV2List()
        ↓
    2. RegisterEventList(EVENT_V2_ATTENDANCE, new CAttendanceEventV2List(EVENT_V2_ATTENDANCE));
        ↓
    3. new CAttendanceEventV2List(eventType) 파생 클래스 생성자 호출
        ↓
    4. CAttendanceEventV2List(eventType) 파생 클래스 생성자 시작
        ↓
    5. CAttendanceEventV2List(eventType)
        : CEventV2ListBase<CAttendanceEventV2Data, stAttendance28ProgressV2Data>(eventType) 베이스 클래스 생성자 시작
        ↓
    6. CEventV2ListBase(ENUM_EVENT_TYPE eventType) 베이스 클래스 생성자 완료
        ↓
    7. CAttendanceEventV2List(eventType) 파생 클래스 생성자 완료
        ↓
    8. CEventV2List::RegisterEventList(ENUM_EVENT_TYPE eventType, IEventV2ListBase* pEventList) 함수 시작
        ↓
    9. map<ENUM_EVENT_TYPE, IEventV2ListBase*> _mapEventLists 멤버 변수에 등록
    void CEventV2List::RegisterEventList(ENUM_EVENT_TYPE eventType, IEventV2ListBase* pEventList)
    {
        if (!pEventList)
        {
            return;
        }
        
        if (g_EventV2Manager.IsEventActive(eventType) == FALSE)
        {
            // 활성화 되지 않은 이벤트는 리스트에 추가하지 않는다. 호출할 때 동적 할당한 메모리 해제
            // 매니저에서 V2 이벤트만 등록 가능하도록 예외처리 해뒀기 때문에 V2 범위가 아니면 여기서 걸러짐
            delete pEventList;
            printf("[EventV2List] Event %d is not active, skipping registration\n", eventType);
            return;
        }
    
        // 기존 이벤트 리스트가 있다면 해제
        auto it = _mapEventLists.find(eventType);
        if (it != _mapEventLists.end())
        {
            if (it->second)
            {
                delete it->second;
            }
        }
    
        // 새 이벤트 리스트 등록
        _mapEventLists[eventType] = pEventList;
    }
        ↓
    10. 2 ~ 9 이벤트 개수 만큼 반복(_mapEventLists에 유저 이벤트별 진행 정보 클래스 캐싱) 후 EventV2List() 생성자 종료
--- **클라이언트 전달** - **enum** **EVENT_PROCESS_TYPE**
cpp
    // 클라 요청 없이 서버 -> 클라로 패킷 전송할 때 사용하는 타입
    enum EVENT_PROCESS_TYPE
    {
    	EVENT_COLLECT_DAY_AQUIRE = 60,
    	EVENT_COLLECT_UPDATE_COUNT = 61,
    
    	EVENT_STACKCHARGE_CHARGE = 100, //23.04.28_남일우_누적충전이벤트
    	EVENT_STACKCHARGE_REWARD = 101,
    	EVENT_STACKCHARGE_CHECK = 102,
    
    	//23.09.12_남일우_윷놀이
    	EVENT_YUT_LOCATION = 103,
    	EVENT_YUT_TODAYCOUNT = 104,
    	EVENT_YUT_ADDCOUNT = 105,
    	EVENT_YUT_INIT = 106,
    	EVENT_YUT_COMPLETE = 107,
    
    	//23.09.26_남일우_버프미션이벤트
    	EVENT_MISSIONBUFF_VALUE = 108,
    	EVENT_MISSIONBUFF_COMPLETE = 109,
    
    	EVENT_CARDGAME_START = 110,
    	EVENT_CARDGAME_CORRECT = 111,
    	EVENT_CARDGAME_STEPREWARD = 112,
    
    	EVENT_HUNTGOD_PROCESS = 113,
    	EVENT_HUNTGOD_REFRESH_MISSION = 114,
    	EVENT_DICEEVENT_DICE_VALUE = 115,
    	EVENT_DICEEVENT_DICE_ADD_VALUE = 116,
    	EVENT_DICEEVENT_COMPLETED_COUNT = 117,
    
    	EVENT_DRAW_ACQUIRE = 120,
    	EVENT_BINGO_BINGO_COUNT = 121,
    	EVENT_BINGO_CUMULATIVE_BINGO = 122,
    	EVENT_BINGO_CUMULATIVE_RESET = 123,
    	EVENT_BINGO_DAY_ACQUIRE = 124,
    	EVENT_BINGO_RESET_COUNT = 125,
    
    	//23.09.26_남일우_버프미션이벤트
    	EVENT_BURNINGMISSION_VALUE = 126,
    	EVENT_BURNINGMISSION_COMPLETE = 127,
    	EVENT_TARGETMISSION_VALUE = 128,
    	EVENT_TARGETMISSION_COMPLETE = 129,
    
    	//24.11.11_김혜연_만두나무이벤트
    	EVENT_MANDU_TREE_ITEM_AND_GRADE_EXP = 130,
    
    	//25.06.27_조현진_딱지 이벤트
    	EVENT_DDAKJI_BOX_COUNT = 133,
    	EVENT_DDAKJI_COMBO_SUCCESS_TYPE = 134,
    };
--- **ENUM_EVENT_PROGRESS_TYPE**
cpp
    // 클라 -> 서버 특정 행동 후 요청 처리 타입
    enum ENUM_EVENT_PROGRESS_TYPE
    {
    	ENUM_EVENT_PASS_REWARD = 1,
    	ENUM_EVENT_YUT_REWARDSELECT = 2,
    	ENUM_EVENT_YUT_THROW = 3,
    	ENUM_EVENT_MISSION_BUFF = 4,
    	ENUM_EVENT_CARD_START = 5, //카드뒤집기 시작 횟수-1
    	ENUM_EVENT_CARD_PAIR = 6, //카드한쌍맞춤성공
    	ENUM_EVENT_CARD_STEPREWARD = 7, //단계보상 받기
    	ENUM_EVENT_CARD_RESET = 8, // 초기화하기
    	ENUM_EVENT_HUNTGOD_REWARD = 9,
    	ENUM_EVENT_HUNTGOD_REFRESH = 10,
    	ENUM_EVENT_DICE_THROW_DICE = 11,
    	ENUM_EVENT_DICE_SELECT_REWARD = 12,
    	ENUM_EVENT_DRAW_SELECT = 13,
    	ENUM_EVENT_DRAW_DRAW = 14,
    	ENUM_EVENT_DRAW_REWARD = 15,
    	ENUM_EVENT_DRAW_NEXT = 16,
    	ENUM_EVENT_BINGO_RANDOM = 17,
    	ENUM_EVENT_BINGO_CHOICE = 18,
    	ENUM_EVENT_BINGO_RESET = 19,
    	ENUM_EVENT_BINGO_CUMUREWARD = 20,
    	ENUM_EVENT_BINGO_LINE = 21,
    	ENUM_EVENT_BURNING_REWARD_SELECT = 22,
    	ENUM_EVENT_HUNTGOD_ACCEPT = 23,
    	ENUM_EVENT_TARGET_MISSON_SELECT = 24,
    	ENUM_EVENT_MANDU_TREE_REWARD = 25,
    	ENUM_EVENT_MANDU_TREE_WATER = 26,
    	ENUM_EVENT_MANDU_TREE_FERTILIZER = 27,
    	ENUM_EVNET_SEVEN_DAY_ATTENDANCE = 28,
    	ENUM_EVENT_EXCHANGE_COLLECTION_SELECT = 29,
    	//ENUM_EVENT_EXCHANGE_SHARE_SELECT = 30,
    	ENUM_EVENT_DDAKJI_EQUIP = 32,
    	ENUM_EVENT_DDAKJI_ATTACK = 33,
    	ENUM_EVENT_DDAKJI_BATTLE_END = 34,
    
    	EVENT_PROGRESS_NONE = 35,
    	EVENT_PROGRESS_ATTENDANCE = 36,          // 출석 여부 (0: 미출석, 1: 출석)
    	EVENT_PROGRESS_REWARD_STEP = 37,         // 보상 단계 (현재 진행 단계)
    	EVENT_PROGRESS_CONTINUOUS_STEP = 38,     // 연속 출석 단계 (누적)
    	EVENT_PROGRESS_CONTINUE_DAY = 39,        // 연속 출석 일수 (현재 연속 일수)
    	
    	// V2 이벤트 진행 타입들
    	EVENT_PROGRESS_V2_ATTENDANCE = 100,     // V2 출석 여부
    	EVENT_PROGRESS_V2_REWARD_STEP = 101,    // V2 보상 단계
    	EVENT_PROGRESS_V2_CONTINUOUS_STEP = 102, // V2 연속 출석 단계
    	EVENT_PROGRESS_V2_CONTINUE_DAY = 103,   // V2 연속 출석 일수
    	EVENT_PROGRESS_V2_ACTIVATION = 104,     // V2 이벤트 활성화 상태
    	EVENT_PROGRESS_V2_DEACTIVATION = 105,   // V2 이벤트 비활성화 상태
    };
--- **ENUM_EVENT_TYPE**
cpp
    // 클라, 서버에서 어떤 이벤트인지 구분하는 타입
    enum ENUM_EVENT_TYPE //번호 바꾸면안됨 
    {
    	EVENT_NONE = 0,							// 이벤트 없음
    	//QET_COMBINE_BUJEOG = 1,						//부적합성횟수달성이벤트
    	//QET_ENCHANT = 2,							//강화횟수달성이벤트
    	//QET_GET_ITEM = 3,							//아이템획득달성이벤트
    	//QET_MAKE_ITEM = 4,							//아이템 제조 횟수달성이벤트
    	//QET_GET_BUJEOG = 5,							//부적획득이벤트 (횟수)
    	//
    	//QET_CASH_PRICE = 7,	// 8(server)					//단일충전
    	//QET_CASH_COMBO = 8,	// 9(server)					//이벤트 기간 내 목표일만큼 연속으로 충전. 달성보상은 일자마다 바뀐다. (보상최대 7일) //23.04.26_남일우_누적충전으로 변경
    	//QET_CASH_SUM = 9,	// 10(server)					//누적충전이벤트(이벤트기간 토탈)
    
    	//QET_DAY_PLAY = 10,							//일일접속이벤트
    
    	//QET_INCREASE_MILEAGE = 11,					//마일리지 추가이벤트
    	//QET_INCREASE_EXP_EVENT = 12,				//경험치이벤트
    	//QET_INCREASE_MONEY_EVENT = 13,				//엽전이벤트
    	//QET_INCREASE_GATHERING = 16,				//채집확률증가
    
    	//QET_COLLECTION_EVENT = 22,  // 수집형
    	//QET_DRAW_EVENT = 23,
    
    	/*EVENT_NEW7 = 100,
    	EVENT_GROWPACK = 101,
    	EVENT_RETURN = 102,*/
    
    	EVENT_STACK_CHARGING = 8, //23.04.24_남일우_충전이벤트
    
    	QET_DRAW_SELECT_REWARD = 23,
    	QET_DRAW_SELECT_DRAW = 24,
    	QET_DRAW_ACQUIRE_REWARD = 25,
    	QET_DRAW_NEXT_STEP = 26,
    
    	QET_BINGO_RANDOM = 50,
    	QET_BINGO_SELECT = 51,
    	QET_BINGO_RESET = 52,
    	QET_BINGO_CUMUREWARD = 53,
    
    	
    
    	// 관우 작업
    	EVENT_ATTENDANCE = 200,			//	일반 출석
    	EVENT_NEWATTENDANCE = 201,		//	신규 출석
    	EVENT_DAY_PLAY = 202,			//	누적 접속
    	EVENT_EXP_BUFF_HIM = 203,		//	힘 숙련도 이벤트
    	EVENT_COLLECT = 204,			//	교환 수집 이벤트
    	EVENT_MISSION = 205,			//	미션(퀘스트) 이벤트 
    	EVENT_EXP_BUFF_MIN = 206,
    	EVENT_EXP_BUFF_CON = 207,
    	EVENT_EXP_BUFF_JOB = 208,
    	EVENT_BINGO = 209,				//	빙고
    	EVENT_DRAW = 210,				//	뽑기
    	EVENT_SPECIAL_ATTENDANCE=211,	// 특별 출석 - 구매o
    	EVENT_LEVELUP_PACKAGE=212,		// 레벨업 이벤트
    
    	EVENT_BUFF_EXP=213,				// 경험치 버프
    	EVENT_BUFF_MONEY=214,			// 엽전 버프
    	
    	EVENT_PLAY_YUT=215,					// 윷놀이 
    	ENUM_EVENT_YUT_REWARDSELECT = 216,
    	ENUM_EVENT_YUT_THROW = 217,
    	EVENT_YUT_INIT = 218, // 골인
    	EVENT_YUT_TODAYCOUNT = 219,
    	EVENT_YUT_ADDCOUNT = 220,
    	EVENT_YUT_COMPLETE = 221,
    	EVENT_YUT_LOCATION = 222,
    
    	EVENT_SPECIAL_ATTENDANCE_FREE = 223,	// 특별 출석 - 구매x
    	// 224 - 클라에서 사용중
    	EVENT_ATTENDANCE_RETURN = 225, // 복귀 유저 출석
    	
    	// V1 이벤트 범위 끝 (1~999)
    	EVENT_V1_RANGE_END = 999,
    	
    	// V2 이벤트 시작 (1000번대부터 V2 전용)
    	EVENT_V2_RANGE_START = 1000,
    	EVENT_V2_ATTENDANCE = 1001,		// V2 출석 이벤트
    	
    	
    	EVENT_V2_RANGE_END = 2000,      // V2 이벤트 범위 끝
    };

